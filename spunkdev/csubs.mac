;       CSUBS
        ; COPYRIGHT 1978, TYMSHARE,INC.
; Following macro names those variablees legal for use as PARAMS and LOCALS
; in this file. Use of these variables in otther situations will lead to
; very interesting bugs.

        define  mac.ok(name)
        <       CKCOMN (NAME,<I,N,R,T,OP,OP1,OP2,OPL,OPM,OPT,OXP,OYP>)
        IFN     $FCKT, < CKCOMN (NAME,<ADRS,CL,ID,INS,LITP,LO,LOK,LVAR,NG,NPAR>) >
        IFN     $FCKT, < CKCOMN (NAME,<PDTP,PROP,REL,RGX,RGY,RN,LNUM>) >
        IFN     $FCKT, < CKCOMN (NAME,<SCD,SDTP,SEG,TQDP,TYP,VL,WW,BP,LVAR,RDN>) > >

PATMSG==0
        EXTERN  RCLN,RDTY
        EXTERN  SDTGET
        EXTERN  OPDSTK,RGSV,FORTYP,FORP,O1P,O2P,PIFXP,OPDN
        EXTERN  RZMA,RZMR,CDEFLG,XTBL,XTBH,LHSH,LIT,SLIT,TQDT,PI,PILO,OPDL,RLNG
        EXTERN  CGOTO,GLREF,STRTUV,MDATPT,ADRPI,SPTADR,EPSADR,CHRADR,ASCADR,LOS
        EXTERN  CSTK,CSTKP,.SLCDR,CLITB,CLITBF,LITBLK
        INTERN  BPOINT,LBPNT
        INTEGER RACHDR,MODE,BPOINT,LBPNT,LHSHP

TQDBLK: BLOCK   TQSZE           ; AREA FOR A BLOCK OF TEMP CELL DESCRIPTORS

VAR
        RELOC   ^O400000
OPCDZ:  POINT   9,0,8           ; XXX XXX XXX ... ... ...  ... ... ... ... ... ...
ACZ:    POINT   4,0,12          ; ... ... ... XXX X.. ...  ... ... ... ... ... ...
INDZ:   POINT   1,0,13          ; ... ... ... ... .X. ...  ... ... ... ... ... ...
XRZ:    POINT   4,0,17          ; ... ... ... ... ..X XXX  ... ... ... ... ... ...
ADZ:    POINT   18,0,35         ; ... ... ... ... ... ...  XXX XXX XXX XXX XXX XXX
RELZ:   POINT   3,0,8           ; ... ... XXX ... ... ...  ... ... ... ... ... ...

; Generate RTVF table.  For each routine in RLIST1, RTVF contains
; <data.type>,,<ng>

        DEFINE  R%R(NAME,LDRNAM,TYPE,NG)
        <
        TYPE,,NG
        >

RTVF:   RLIST1

WDSIZ:  EXP     1,1,1,2,2,2
RLRV:   EXP     0,7,2,5,4,3,6,1
                                ;       CLINS  table that tells us what instruction to call a procedure with
CLINS:  JSP     1,0             ; normal TBA
        JSP     1,0             ; entry
        JSP     1,0             ; plain external
        JSP     1,0             ; TBA
        PUSHJ   ^O17,0          ; SFO
        JSA     ^O16,0          ; CFO
        PUSHJ   ^O17,0          ; SIMPL
        PUSHJ   ^O17,0          ; BLISS

                                ;       type codes for CFO
CFOT:   EXP     3,0,2,6,7,5

                                ;       type codes for SFO
SFOT:   EXP     ^O40,^O100,^O200,^O400,^O600 ; logical,integer,real,double,complex
EREG:   EXP     0,0,0,0,0,0,1,3

;       THE ARRAY DESCRIPTOR SIZE TABLE
        SALL
.SZDSC: SZTARY
;       WORST CASE FOR AN ARRAY DESCRIPTOR
; that is how big it could be if you dont know whether its a slice or not
.WSTCS: WSTDSC

; ACCES CODE OFFSET FOR ARRAY DESCRIPTORS
        INTERN  .CADR
.CADR:  CADRTB

        EXTERN  VSTART,VNEXT,ALLOCS,CMSG,CXR2,CXTDO,TDO,ESCFLG,IISC
        EXTERN  GETID,GLNUM,MBUF,MBUFD,PARDT,PRODT,PSW,SETDOL,SWPSCT
        EXTERN  TLOC,TNEW,TNEXT,TRLS,TSET,VRLS,CNERR,LRTP,PREL,GDIM
        EXTERN  RTAD,RTFG,CERCNT,TRVT,TRVN,PREG,SUBNM,PMCP,PMCK,DSFLG
        EXTERN  FORSTK,TPOP,FDIM,DEBGSW,CHRTBL,ASCTBL,SPOINT,EPS
        EXTERN  LVNP7,DIRLVR,VGET,VPUT
        INTERN  SGNAM,CERR,.SZDSC

SGNAM:  [ASCIZ /  ABS/]
        [ASCIZ  /  LVR/]
        [ASCIZ  /  LOC/]
        [ASCIZ  / FIXUP /]



;              ******        ****      ********    ******    **    **        **      ****
;              **    **    **    **    **      **    **      **    **      ****    **    **
;              **    **    **    **    **      **    **       **  **         **    **    **
;              ******      ********    **      **    **        ****          **    **    **
;              **    **    **    **    **      **    **       **  **         **    **    **
;              **    **    **    **    **      **    **      **    **        **    **    **
;              **    **    **    **    ********    ******    **    **      ******    ****

        RADIX   10

;******* WHEN MODIFYING CSUBS, PLEASE USE ^D AND ^O FOR CLARITY ********

        TITLE   CSUBS
        SUBTTL RZUM  RESUME FROM AN ERROR

; YOU GET TO RZUM AFTER YOU HAVE GOTTEN AN ERROR.
; TYPICLY,THE SCENARIO GOES SOMTHING LIKE THIS:
;  YOU WERE IN COMPIL AND GOT AN ERROR. YOU CALL CERR OR SOMTHING TO PRINT
;  AN ERROR MESSAGE. CERR DOSNT RETURN BUT RATHER CALLS RZUM. RZUM THEN
;  READS THE REST OF THE PMC FOR THE LINE LOOKING FOR THINGS LIKE ORIFS,
;  ELSES,NEXTS AND STUFF LIKE THAT SO IT CAN KEEP THE CSTACK AND FORSTK IN
;  ORDER. THEN IT ADJUSTS  THE STACK POINTER AND JUMPS TO CWPRG4 (UNLESS
;  WE ARE COMPILING A DIRECT STATEMENT IN WHICH CASE IT GOES SOMPLACE IN
;  CDST)

; THE PMCS IT WATCHES FOR TO TAKE CARE OF THE CSTACK ARE:
;  BGTST and BGFTS  WHICH MAKE A CSTACK ENTRY
;  ENDIF            WHICH POPS A CSTACK ENTRY
;  ELSE,ORIF,UNLESS,WHILE,UNTIL and IF  WHICH CHANGE THE CMODF FIELD

; THE PMCS IT WATCHES FOR TO TAKE CARE OF THE FORSTK ARE:
;  FORID and IFRID  WHICH MAKE A FORSTK ENTRY
;  NEXT and ITDON   WHICH POP A FORSTK ENTRY
;     (NXMAX,NXMIN,NXSUM, and NXPRD ARE ALWAYS FOLLOWED BY AN ITDON)

        DCL     RZUM,<SVOPTP,SVPMCP>

        MOVE    0,PMCP          ;GET THE PMC POINTER

RZUMA:  ILDB    1,0             ;read a pmc
        MOVEM   1,SVOPTP
        CAIN    1,^D254         ;is it an ENDLN
        JRST    RZUM$

        MOVEM   0,SVPMCP        ;SAVE THE PMCP

        CAIE    1,^D97          ;BGTST
        CAIN    1,^D117         ;BGFTS
        JRST    RZUMB1          ;STACK A CSTK ENTRY

        CAIE    1,^D51          ;FORID
        CAIN    1,^D118         ;IFRID
        JRST    RZUMB2          ;STACK A FORSTK ENTRY

        CAIN    1,1             ;ENDIF
        JRST    RZUMB3          ;POP THE CSTK

        CAIE    1,^D61          ;NEXT
        CAIN    1,^D123         ;ITDON
        JRST    RZUMB4          ;POP THE FORSTK

        CAIE    1,0             ;ELSE
        CAIN    1,^D102         ;ORIF
        JRST    RZUMB5

        CAIE    1,^D243         ;SCON
        CAIN    1,^D257         ;AKA
        JRST    RZUMB6          ;SKIP OVER STRING CONSTANT IN PMCS

        CAIE    1,^D80          ;ONGO
        CAIN    1,^D81          ;ONGSB
        JRST    RZUMB7          ;SKIP OVER LINE # LIST IN PMCS

        CAIL    1,^D26          ;CHECKING FOR:
        CAILE   1,^D29          ; UNLESS,WHILE,UNTIL,IF
        JRST    RZUMC

RZUMB5: CALL    TLOC,<$,CSTK,0>
        MOVE    0,SVOPTP
        FPUT    0,1,CMODF
        CALL    RDTY
        JRST    RZUMC

RZUMB1: CALL    TNEW,<$,CSTK>
        CALL    RCLN
        JRST    RZUMC

RZUMB2: CALL    TNEW,<$,FORSTK>
        CALL    RCLN
        JRST    RZUMC

RZUMB3: CALL    TPOP,<$,CSTK>
        JRST    RZUMC

RZUMB4: CALL    TPOP,<$,FORSTK>
        JRST    RZUMC


RZUMB6: MOVE    0,SVPMCP
        ILDB    1,0             ;GET NUMBER OF CHARACTERS
        JRST    RZUMC3

RZUMB7: MOVE    0,SVPMCP
        ILDB    1,0             ;GET NUMBER OF LINE NUMBERS
        IMULI   1,3             ;EACH ONE TAKES THREE PMCS
        JRST    RZUMC3

RZUMC:  MOVE    1,SVOPTP        ;GET THE OPTYPE
        CAILE   1,^D125         ;ACCOUNT FOR THE HOLE IN THE PMC LIST
        JRST    RZUMC1
        IDIVI   1,^D9
        MOVE    0,RZTBLO(1)     ;LOOK INTO TABLE FOR PMCS <125
        JRST    RZUMC2

RZUMC1: SUBI    1,^D235
        IDIVI   1,^D9
        MOVE    0,RZTBHI(1)     ;LOOK INTO TABLE FOR PMCS >234

RZUMC2: LDB     1,RZBP(2)       ;GET NUMBER OF PMCS TO SKIP OVER
        MOVE    0,SVPMCP

RZUMC3: SOJL    1,RZUMA         ;AC1 TELLS US HOW MANY PMCS TO SKIP
        IBP     ,0
        JRST    RZUMC3

RZUM$:  MOVE    P,RZMR          ;KILL THE STACK

        JRST    @RZMA           ;JRST TO THE RETURN POINT


;  BYTE POINTERS USED TO GET STUFF OUT OF RZTBLO AND RZTBHI
RZBP:   POINT   4,0,3
        POINT   4,0,7
        POINT   4,0,^D11
        POINT   4,0,^D15
        POINT   4,0,^D19
        POINT   4,0,^D23
        POINT   4,0,^D27
        POINT   4,0,^D31
        POINT   4,0,^D35


; THESE TABLES TELL US HOW MANY BYTES OF PMC EACH OPTYPE USES. WE USE IT
; TO SCAN THROUGH THE PMC FOR THE REST OF THE LINE


        PMCEXP=0
        PMCCNT=9

        DEFINE PMC(NUMBER,NAME,DECLR,COMPL,SIGHZE)
        <
        PMCCNT=PMCCNT-1
        PMCEXP=PMCEXP*^D16
        PMCEXP=PMCEXP+SIGHZE-1
        IFE PMCCNT,<
                   LIST
                   EXP PMCEXP
                   XLIST
                   PMCCNT=9
                   PMCEXP=0
                   >>

        XLIST
RZTBLO: LOPMCS
        IFN PMCCNT-9,<REPEAT PMCCNT,<PMCEXP=PMCEXP*^D16
                                    >
                        LIST
                        EXP PMCEXP
                        XLIST
                        PMCCNT=9
                        PMCEXP=0
                        >

RZTBHI: HIPMCS
        IFN PMCCNT-9,<REPEAT PMCCNT,<PMCEXP=PMCEXP*^D16
                                    >
                      LIST
                      EXP PMCEXP
                      >
        LIST


        SUBTTL AC1 LOAD AN NUMERIC SCALER INTO AC1
        DCL     AC1

;                               AC1 1
        CALL    CKC,<$,O2P,ONSC>
        CALL    LDR,<1,$,O2P>
        CALL    OREM,<1>
        CALL    SAVREG

;                               EXIT AC1
        RETURN  AC1
        SUBTTL AC13 LOAD NUMERIC SCALERS INTO ACs 1 AND 3
        DCL     AC13

;                               AC13 1
        CALL    CKC,<$,O2P,ONSC>
        CALL    CKC,<$,O1P,ONSC>
        CALL    LDR,<3,$,O2P>
        CALL    LDR,<1,$,O1P>
        CALL    OREM,<2>
        CALL    SAVREG

;                               EXIT AC13
        RETURN  AC13
        SUBTTL AC1S  LOAD A STRING
        DCL     AC1S,,<SCD>

;                               AC1S 1
        CALL    CKC,<$,O2P,OSSC>
        CALL    LDS,<2,$,O2P>,<SCD>
        CALL    OREM,<1>
        CALL    SAVREG
        MOVSI   0,(MOVEI 5,)
        HRR     0,SCD
        SETZ    1,0
        CALL    GRI

;                               EXIT AC1S
        RETURN  AC1S
        SUBTTL AC2S     LOAD TWO STRINGS
        DCL     AC2S,,<SCD>

;                               AC2S 1
        CALL    CKC,<$,O2P,OSSC>
        CALL    CKC,<$,O1P,OSSC>
        CALL    LDS,<1,$,O1P>
        LSH     1,2
        MM      1,SCD
        CALL    LDS,<2,$,O2P>
        ADDM    1,SCD
        CALL    OREM,<2>
        CALL    SAVREG
        MOVSI   0,(MOVEI 5,)
        HRR     0,SCD
        SETZ    1,0
        CALL    GRI

;                               EXIT AC2S
        RETURN  AC2S
        SUBTTL ACNS   LOAD A NUMERIC SCALAR AND A STRING
        DCL     ACNS,,<SCD>

;                               ACNS 1
        CALL    CKN1,<$,O1P>
        CALL    CKC,<$,O2P,OSSC>
        CALL    LDS,<1,$,O1P>
        CALL    LDS,<2,$,O2P>,<SCD>
        CALL    OREM,<2>
        CALL    SAVREG
        MOVSI   0,(MOVEI 5,)
        HRR     0,SCD
        SETZ    1,0
        CALL    GRI

;                               EXIT ACNS
        RETURN  ACNS
        SUBTTL ACSN     LOAD A STRING AND A NUMERIC SCALAR
        DCL     ACSN,,<SCD>

;                               ACSN 1
        CALL    CKN1,<$,O2P>
        CALL    CKC,<$,O1P,OSSC>
        CALL    LDR,<1,$,O2P>
        CALL    LDS,<2,$,O1P>,<SCD>
        CALL    OREM,<2>
        CALL    SAVREG
        MOVSI   0,(MOVEI 5,)
        HRR     0,SCD
        SETZ    1,0
        CALL    GRI

;                               EXIT ACSN
        RETURN  ACSN
        SUBTTL CALLX    CALL A SUBROUTINE
        DCL     CALLX,<N>,<SDTP>

;                               CALL 1
        CALL    GETID,,<SDTP>

;                               CALL 2

        FGET    0,1,SKND        ;SDTP IN R1, ABOVE
        CAIN    0,SPRO
        J       CALL5

;                               CALL 4  error 'SUBROUTINE NAME REQUIRED'
        SKIPE   N       ; THERE MAY BE A PMC WITH # OF ARGS
        ILDB    1,PMCP  ;CLEAN UP FOR RZUM WHO READS PMC
        CALL    CERR,<^D17>

;                               CALL 5
CALL5:  SKIPN   N
        J       CALL7

;                               CALL 6
        ILDB    1,PMCP
        MM      1,N
        SOS     PMCK

;                               CALL 7
CALL7:  CALL    CALLF,<$,SDTP,$,N,0>

;                               EXIT CALL
        RETURN  CALLX
        SUBTTL CALLF    CALL A PROCEDURE AND MAYBE STACK THE RESULT

;       SDTP  SDT table entry for the procedure
;       NPAR  number of parameters
;       RFLG  =0 if a CALL statement, =1 for a function call
;
; Some of the things CALLF concerns itself with:
; -We make sure we have the right number of parameters unless its fortran
; -We save all busy registers, except those holding parameters
; -We convert the parameters to the required types and pass them to the
;   procedure. Then we unstack them.
; -We save all busy tempcells into a safe place, because those same temp
;   cells may be used by whoever we are calling.
; -We put out code for the actual call. The table CLINS tells us whether to
;   use a pushj or jsp or whatever.
; -We maybe allocate a tempcell for the result of a string or array valued
;   procedure.
; -We put out an argument list for CFO and SIMPL procedures
; -We call a routine CSTAK to stack the result
; -We call a routine CDALA for external procedures

; The Mode Codes :
;    0- normal   1- ENTRY    2- plain external    3- TBA
;    4- SFO      5- CFO      6- SIMPL             7- BLISS

; see appendix e of the TYMBASIC REFERENCE MANUAL for info on the calling sequences

        DCL     CALLF,<SDTP,NPAR,RFLG>,<PROP,LOK,REL,TYP,SAD,SRN,SCD,WW,WWWW,OP,R,RR,INS,PDTP,JSALOC,HSGLOC,XTRPAR>

;                               CALLF 1
        CALL    TTLOG
        M       2,SDTP
        FGET    1,2,SN
        CALL    TLOC,<$,PRODT>,<PROP>

;                               CALLF 2  DO WE HAVE THE CORRECT NUMBER OF PARAMETERS
        M       2,PROP
        FGET    1,2,PMODD
        CAIE    1,4             ; IF ITS SFO
        CAIN    1,5             ; OR CFO
        JRST    CALLF5          ; THEN DONT CHECK NUMBER OF PARAMETERS
                                ;       BECAUSE FORTAN CAN HAVE VARIABLE NUMBER OF PARAMETERS
        FGET    1,2,PNP
        CAMN    1,NPAR
        J       CALLF5

;                               CALLF 3  NO, GET NAME . . 
        M       2,PROP
        FGET    1,2,PNAM
        EXCH    1,2
        CALL    RCLN
        MOVE    1,2

;                               CALLF 4   . . AND GIVE ERROR
        CALL    CERRN,<6>

;                               CALLF 5  YES, SAVE SOME REGISTERS
CALLF5: BCALL   CSAV


;                               CALLF 6  PASS PARAMETERS TO PROCEDURE
        BCALL   CNVP

;                               CALLF 6 1/2  MOVE TEMP CELLS TO A SAFE PLACE
        BCALL   QSAV

;                               CALLF 7 MODE = ?
        M       1,MODE
        CAILE   1,3
        JRST    0,@MOTBL(1)

;                       CALLF 8 TBA, MOVE TEMP CELLS TO A SAFE PLACE
        J       CALF11
MOTBL=.-4
        CALLF9                  ;SFO
        CALF10                  ;CFO
        CALF12                  ;SIMPL
        CALF11                  ;BLISS

;                       CALLF 9 AN SFO PROCEDURE
                        ; PASS ADDR OF ARGUMENT LIST IN AC 16 OCTAL
CALLF9: M       1,SDTP
        FGET    0,1,SLOC
        HRLI    0,(MOVEI 14,)
        ADDI    0,4
        CALL    GRI,<,UVAR>
        J       CALF11

;                       CALLF 10 A CFO PROCEDURE
                        ; GENERATE JRST TO THE JSA IN THE LOSEG
calf10: movsi   0,(jrst)
        hrr     0,jsaloc
        call    gri,<,lvr>
        move    0,r%cdlc
        movem   0,hsgloc
        skipe   relflg##        ; rel file requested?
        jrst    calf11          ;  no
        scall   r%cdst,<$,jsaloc,rlvar>

;                       CALLF 11  GENERATE THE ACTUAL CALL TO THE PROCEDURE
CALF11: CALL    GRLB,<$,PROP>
        M       2,PROP
        FGET    0,2,PFXP
        M       2,MODE
        HLL     0,CLINS(2)      ;CLINS is a table with JSPs and PUSHJs in it
        CALL    GRI

;                       CALLF 18
        M       2,PROP
        FGET    1,2,PUSD
        SALL
        jumpe   1,[       move 0,r%cdlc
        subi    0,1
        fput    0,2,pfxp
        jrst    .+1  ]
        XALL

;                       CALLF 12  MODE = ?
CALF12: M       1,MODE
        CAIE    1,4             ; SFO
        CAIN    1,7             ; BLISS
        J       CALF28
        CAILE   1,3             ; any TBA
        J       CALF23

;                       CALLF 13  TBA , CHECK FOR STRING OR ARRAY VALUED PROC. . .
        SKIPLE  FDIM
        JRST    CAL14B
        M       2,SDTP
        FGET    0,2,STYP
        CAIE    0,STR
        J       CALF29

;                       CALLF 14  . . AND MAYBE ALLOCATE TEMP SPACE FOR THE RESULT
CAL14A: CALL    TQSFND
        JRST    CAL14C
CAL14B: MOVE    1,FDIM
        MOVE    1,.WSTCS(1)
        CALL    TQAFND,<$,1>
CAL14C: MOVEM   1,SAD
        MOVEM   2,SRN
        CALL    GRI,<$,1,LVR>
        JRST    CALF29

;                       CALLF 23  CFO OR SIMPL
CALF23: BCALL   CCFSI

;                       CALLF 24
        M       1,MODE
        CAIN    1,6     ; simpl
        J       CALF26

;                       CALLF 25  for CFO, generate JRST back to hiseg
        MOVE    0,HSGLOC        ; save current hiseg location
        HRLI    0,(JRST)
        CALL    GRI,<,LOC>
        skipe   relflg##        ; rel file requested?
        jrst    calf28          ;  no
        scall   r%cdst,<$,hsgloc,rlcode>
        J       CALF28

;                       CALLF 26 for SIMPL, we generate the PUSHJ 17, here
CALF26: CALL    GRLB,<$,PROP>
        M       2,PROP
        FGET    0,2,PFXP
        HRLI    0,(PUSHJ ^O17,)
        CALL    GRI
        M       1,r%cdlc
        SUBI    1,1
        M       2,PROP
           1,2,PFXP

;                       CALLF 28
CALF28: M       2,SDTP
        FGET    1,2,SLOC
        CALL    CSRRG,<0>
        SETZM   SRN

;                       CALLF 29  STACK RESULT OF THE PROCEDURE
CALF29: BCALL   CSTAK

;                       CALLF 30
        M       1,MODE
        CAIG    1,3
        J       CALF32

;                       CALLF 31  DO SOME EXTRA STUFF FOR NON TBA PROCEDURES
        BCALL   CDALA

;                       CALLF 32
CALF32: MOVE    R1,PROP
        CALL    RDTY

;                               EXIT CALLF
        RETURN  CALLF
        SUBTTL CSAV CALLF.5  SAVE REGISTERS AS REQUIRED FOR A PRCEDURE CALL
        BDCL    CSAV

;                               CSAV 1
        M       1,PROP
        FGET    0,1,PMODD
        MM      0,MODE
        FGET    0,1,PFDIM
        MM      0,FDIM
        M       1,OPDN
        SUB     1,NPAR
        MM      1,WW
        SETZM   R
        M       1,SDTP
        FGET    0,1,SLOC
        MM      0,LOK

;                               CSAV 2
CSAV2:  M       1,R
        M       2,RGSV(1)
        MM      2,RR

;                               CSAV 3
        JLE     2,CSAV5         ; RR IN R2, BOX 2
        CAMLE   2,WW
        J       CSAV5

;                               CSAV 4
CSAV4:  BCALL   SVOR

;                               CSAV 5
CSAV5:  AOS     1,R

;                               CSAV 6
        CAIG    1,10
        J       CSAV2

;                       CSAV 7
        M       1,MODE
        MI      2,2
        CAIG    1,1
        ADDM    2,LOK
        CAIG    1,3
        J       CSAV$$
;                       CSAV 8
        CALL    CSRRG,<1,$,LOK>,<LOK>

;                               EXIT CSAV
CSAV$$: BRETURN CSAV
        SUBTTL SVOR CALLF.5.4   STORE A REG IN A PROTECTED AREA
        BDCL    SVOR

;                               SVOR 1
        M       1,RR
        M       2,OPDL(1)
        MM      2,OP
        CALL    MMI,<$,r%vrlc,$,OP,LVR,0>

;                               SVOR 2
        M       2,OP
        FGET    1,2,OM
        CAIE    1,OSUB
        J       SVOR4

;       SVOR 3, OP USED FROM R2, BOX 2
        M       1,r%vrlc
        FPUT    1,2,OL
        MI      1,0
        FPUT    1,2,OV
        FPUT    1,2,ONG
        AOS     r%vrlc
        J       SVOR$$

;               SVOR 4 OP USED FROM R2, BOX 2
SVOR4:  MI      1,OLVAR
        FPUT    1,2,OM
        M       1,r%vrlc
        FPUT    1,2,OL
        MI      1,0
        FPUT    1,2,OV

;                               SVOR 5
        FGET    1,2,OT          ; OP IN R2, BOX 2
        M       1,WDSIZ(1)
        ADDM    1,r%vrlc

;                               EXIT SVOR
SVOR$$: BRETURN SVOR
        SUBTTL CNVP CALLF.6 CONVERT PARAMETERS TO PROPER TYPE AND PASS TO PROCEDURE
        BDCL    CNVP

;                       CNVP 01
        M       1,MODE
        JRST    @MDTBL(1)
MDTBL:  CNVP04                  ; normal
        CNVP04                  ; ENTRY
        CNVP05                  ; EXTERNAL (plain)
        CNVP05                  ; TBA
        CNVP06                  ; SFO
        CNVP07                  ; CFO
        CNVP1                   ; SIMPL
        CNVP1                   ; BLISS

;                       CNVP 04   NORMAL OR ENTRY
CNVP04: MI      1,UVAR
        MM      1,REL
        J       CNVP1

;                       CNVP 05    TBA EXTERNAL
;       for an external TBA procedure we have to get the address of the
;       first parameter in the parameter vector which was stored in the
;       word preceeding the first word of the procedure body. so we:
;       MOVE 13,FOO
;       MOVE 13,-1(13)

;       GRLB determines the relocation mode for a procedure call
;       it depends on whether weve compiled the procedure yet.
CNVP05: CALL    GRLB,<$,PROP>
        M       2,PROP
        FGET    0,2,PFXP
        HRLI    0,(MOVEI 11,)
        CALL    GRI
        M       1,r%cdlc
        SUBI    1,1
        M       2,PROP
        FPUT    1,2,PFXP
        M       0,[MOVE 11,-1(11)]
        CALL    GRI,<,0>
        MOVSI   0,11            ; 11 in the index field
        MM      0,LOK
        SETZM   0,REL
        J       CNVP1

;                       CNVP 06    SFO
CNVP06: MOVN    0,NPAR
        HRLI    0,(MOVSI 11,)
        CALL    GRI,<,0>
        M       0,LOK
        HRLI    0,(MOVEM 11,)
        CALL    GRI,<,UVAR>
        AOS     LOK
        J       CNVP1

;                       CNVP 07   CFO
cnvp07: move    sa1,npar
        addi    sa1,2
        skipe   relflg##        ; rel file requested
        jrst    cnvp08          ; no
        scall   r%var,<>,<jsaloc>
cnvp08: addi    sr1,1
        movem   sr1,lok
        MI      1,LVR
        MM      1,REL

;                               CNVP 1
CNVP1:  MOVE    R0,NPAR         ;Number of parameters
        MOVEM   R0,WWWW
        SETZ    XTRPAR          ; NO EXTRA PARAMETERS SEEN YET
        MOVE    R2,PROP
        FGET    1,2,PPARS
        MOVEM   R1,WW           ; RECORD NUMBER OF FIRST PARAMETER
        M       1,OPDN
        SUB     1,NPAR
        M       2,OPDL(1)
        MOVEM   2,OP            ; START WITH FIRST PARAMETER

;                               CNVP 2
CNVP2:  SKIPG   WWWW            ; WE COUNT DOWN ON WWWW
        JRST    CNVP$$
        SKIPLE  WW               ;PARDT RECORD NUMBER, ZERO IF NO MORE RECORDS
        JRST    CNVP3

        ; WHEN WE GET HERE WE HAVE AN EXTRA PARAMETER, THAT IS THE USER CALLED
        ; THE PROCEDURE WITH MORE PARAMETERS THAN WAS LISTED IN THE DEF. THIS
        ; IS CURRENTLY LEGAL ONLY FOR THE FORTRANS.

        ; WE DONT HAVE A PDTP RECORD FOR THIS PARAMETER SO ALL WE DO IS PASS IT


        SETOM   XTRPAR  ; XTRPAR#0 MEANS WE HAVE AN EXTRA PARAMETER
        MOVEI   1,4
        ADDM    1,OP    ; GET THE NEXT PARAMETER (ITS SITTING ON THE OP STACK)
        SOS     WWWW
        MOVE    1,OP
        FGET    2,1,OT
        MOVEM   2,TYP
        FGET    2,1,OC
        CAIE    2,OMX
        JRST    CNVP5
        JRST    CNVP7
        ; i know this is a little messy but i dont want to change those bdcls to dcls


;                               CNVP 3
CNVP3:  MI      1,4
        ADDM    1,OP
        CALL    TLOC,<$,PARDT,$,WW>,<PDTP>
        FGET    R0,R1,PARLNK
        MOVEM   R0,WW           ; WE FOLLOW THE LINK TO THE NEXT PARDT ENTRY
        SOS     WWWW            ; COUNT DOWN ON NUMBER OF PARAMETERS
        FGET    0,1,PATYP
        MM      0,TYP

;                               CNVP 4
        M       2,PDTP
        FGET    1,2,PAKND
        CAIN    1,SPARY
        J       CNVP6
        CAIE    1,SSCAL
        J       CNVP9

;                               CNVP 5 CONVERT SCALAR TO PROPER TYPE AND PASS IT
CNVP5:  BCALL   CNSC
        JRST    CNVP7H

;                               CNVP 6 IS THE ARGUMENT OF PROPER TYPE AND DIMENSIONALITY?
CNVP6:  M       2,OP
        FGET    1,2,OC
        CAIE    1,OMX
        J       CNVP8
        FGET    1,2,OT
        M       4,PDTP
        FGET    3,4,PATYP
        CAME    1,3
        J       CNVP8
        FGET    1,2,ONG
        FGET    3,4,PASN
        CAME    1,3
        J       CNVP8

;                               CNVP 7   YES, PASS THE ARRAY
CNVP7:  BCALL   CNAY

;                       CNVP 7 1/2
CNVP7H: MOVE    1,PDTP
        SKIPN   XTRPAR  ; UNLESS THIS IS AN EXTRA PARAAMETER (IN WHICH CASE THERE
                        ; WOULD BE NO PDTP RECORD), FREE THE PDTP RECORD
        CALL    RCLN
        JRST    CNVP2

;                               CNVP 8   NO, GIVE ERROR
CNVP8:  M       1,PDTP
        FGET    2,1,PANAM
        CALL    RCLN
        MOVE    R1,PROP
        CALL    RCLN
        MOVE    1,2
                                ;       'ATTEMPT TO ASSIGN INCOMPATIBLE VALUE TO FORMAL PARAMETER ____'
        CALL    CERRN,<37>

;                               CNVP 9 OPPS, SOMEBODY PUT A PROCEDURE OR A
;                               NON PARAMETER ARRAY INTO THE PARDT AS A
;                               PARAMETER. IT MAY BE IMPOSSIBLE TO GET HERE
CNVP9:  MOVE    R1,PDTP
        CALL    RCLN
        CALL    IMPOS


;                               EXIT CNVP
CNVP$$: BRETURN CNVP
        SUBTTL CNSC CALLF.6.5 CONVERT SCALAR (NUMERIC OR STRING) TO PROPER TYPE AND PASS IT
        BDCL    CNSC

;                               CNSC 1  STRING OR NUMERIC?
        M       1,TYP
        CAIN    1,STR
        J       CNSC8

;                               CNSC 2   NUMERIC
        MOVE    1,OP            ; THE DEF SAID NUMERIC SCALAR, NOW WE CHECK THE OPERAND
        FGET    0,1,OC
        CAIE    0,ONSC          ; IF ITS NOT A NUMERIC SCALAR
        JRST    CNSC9           ; THEN ERROR 'OPERAND OF WRONG TYPE'

;                       CNSC 3  CONVERT OPERAND TO TYPE SPECIFIED IN THE DEF
        CALL    CNVRT,<$,OP,$,TYP>

;                       CNSC 4 DO WE HAVE A DOUBLE ARG IN A CFO PROCEDURE?
        M       1,TYP
        CAIE    1,DBL
        J       CNSC7
        M       1,MODE
        CAIE    1,5             ;CFO
        J       CNSC7

;                       CNSC 5  YES, WE MAKE A SOFTWARE DOUBLE FROM A HARDWARE DOUBLE
        CALL    LDR,<1,$,OP>
        SETZM   0,RGSV+1
        SETZM   0,RGSV+2
        CALL    SAVREG

;                       CNSC 6  AND IT TAKES A LOT OF INSTRUCTIONS
        M       0,[M 0,1]
        CALL    GRI,<,0>
        M       0,r%cdlc
        HRLI    0,(JUMPE)
        ADDI    0,9
        CALL    GRI,<,LOC>
        M       0,[LSH 1,-27]
        CALL    GRI,<,0>
        M       0,[TRNE 1,^O400]
        CALL    GRI,<,0>
        M       0,[TRC 1,^O777]
        CALL    GRI,<,0>
        M       0,[SUBI 1,27]
        CALL    GRI,<,0>
        M       0,[TRNE 1,^O400]
        CALL    GRI,<,0>
        M       0,[SETZB 1,2]
        CALL    GRI,<,0>
        M       0,[LSH 2,1]
        CALL    GRI,<,0>
        M       0,[LSHC 1,27]
        CALL    GRI,<,0>
        SETZ    1,0
        M       2,OP
        FPUT    1,2,OL
        SUBI    2,OPDSTK
        LSH     2,-2
        MM      2,RGSV
        MM      2,RGSV+1

;                       CNSC 7  PASS THE NUMERIC SCALAR
CNSC7:  BCALL   CNSPN
        J       CNSC$$

;                       CNSC 8 STRING
CNSC8:  MOVE    1,OP            ; THE DEF SAID STRING SCALAR, NOW WE CHECK THE OPERAND
        FGET    0,1,OC
        CAIN    0,OSSC
        J       CNSC10

;                       CNSC 9  OPERAND OF WRONG TYPE
CNSC9:  M       1,PDTP
        FGET    2,1,PANAM
        CALL    RCLN
        MOVE    R1,PROP
        CALL    RCLN
        MOVE    R1,R2
        CALL    CERRN,<37>

;                       CNSC 10 PASS THE STRING SCALAR
CNSC10: BCALL   CNSPS

;                       EXIT CNSC
CNSC$$: BRETURN CNSC
        SUBTTL CNSPN CALLF.6.5.7   PASS THE NUMBER
        BDCL    CNSPN
;                       CNSPN 1
        MOVE    1,MODE          ; WE DONT WORRY ABOUT SIMPL, CCFSI DOES IT
        CAIN    1,6
        J       CSPN$$
        CAILE   1,3
        J       CNSPN5
;                       CNSPN 2  TBA
        M       1,OP
        FGET    0,1,OM
        CAIN    0,OREG
        J       CNSPN4
;                       CNSPN 3
        CALL    LD,<$,OP>
;                       CNSPN 4
CNSPN4: CALL    MMI,<$,LOK,$,OP,$,REL,0>
        M       1,TYP
        M       2,WDSIZ(1)
        ADDM    2,LOK
        J       CSPN$$
;                       CNSPN 5  NON TBA
                                ;       RESOLVE PENDING NEGATION
CNSPN5: CALL    NNG1,<$,OP>
        MI      1,LVR
        MM      1,REL
;                       CNSPN 6
        M       1,OP
        FGET    0,1,OM
        CAIN    0,OLVAR
        J       CSPN12
        CAIE    0,OUVAR
        J       CNSPN8
;                       CNSPN 7
        MI      1,UVAR
        MM      1,REL
        J       CSPN12
;                       CNSPN 8
CNSPN8: CALL    LD,<$,OP>
;                       CNSPN 9
        M       2,MODE
        CAIE    2,7
        J       CSPN11
;                       CNSPN 10
        SETZM   0,REL
        J       CSPN12
;                       CNSPN 11
CSPN11: M       0,1
        CALL    SVR
;                       CNSPN 12
CSPN12: M       1,MODE
        CAIN    1,7
        J       CSPN15
        CAIN    1,5
        J       CSPN14
;                       CNSPN 13  SFO
                                ;       FIND A REGISTER , R
        CALL    FNDR,<1>,<R>
        CALL    SVR,<$,R>
        M       1,OP
        FGET    0,1,OL
        HRLI    0,(MOVEI)
        M       1,R
        DPB     1,ACZ
                                ;       MOVEI R,
        CALL    GRI,<,$,REL>
        M       1,TYP
        M       0,SFOT(1)
        HRLI    0,(HRLI)
        M       1,R
        DPB     1,ACZ
                                ;       HRLI R,SFOT(TYP)
        CALL    GRI,<,0>
        M       0,LOK
        HRLI    0,(MOVEM)
        M       1,R
        DPB     1,ACZ
                                ;       MOVEM R,LOK
        CALL    GRI,<,UVAR>
;                       CNSPN 14  CFO
CSPN14: AOS     LOK             ; REMEMBER CFOs WORK IS DONE IN CCFSI
        J       CSPN$$
;                       CNSPN 15  BLISS
CSPN15: M       1,OP
        FGET    0,1,OL
        HRLI    0,(PUSH 15,)
        CALL    GRI,<,$,REL>
;                       CNSPN 16
        M       1,TYP
        CAIG    1,REAL
        J       CSPN$$
;                       CNSPN 17
        M       1,OP
        FGET    0,1,OL
        ADDI    0,1
        HRLI    0,(PUSH 15,)
        CALL    GRI,<,$,REL>
;                       EXIT CNSPN
CSPN$$: BRETURN CNSPN
        SUBTTL CNSPS CALLF.6.5.10  PASS A STRING
        BDCL    CNSPS
;                       CNSPS 1
        M       1,MODE
        CAIN    1,6
        J       CSPS$$
        CAILE   1,3
        J       CNSPS3
;                       CNSPS 2   TBA
        CALL    LDS,<2,$,OP>,<SCD>
        SETZM   0,RGSV+2
        CALL    SAVREG
        M       0,SCD
        HRLI    0,(MOVEI 5,)
        CALL    GRI,<,0>
        MOVSI   0,(MOVEI 1,)
        OR      0,LOK
        CALL    GRI,<,$,REL>
        CALL    CXR,<RXAS>
        MI      0,2
        ADDM    0,LOK
        J       CSPS$$

;                       CNSPS 3   NON-TBA
; When we pass strings (or arrays) to non-tba procedures we must take note
; of their mode. If its a temp then we must free the body after the call while if
; its a consatnt or variable we most certainly must not.
; The problem is if we mess with our only copy of the operand (which were about
; to do) we may move it into a register and lose track of whether its a temp or
; varaible or what. To solve this problem we stack a copy of the operand to use
; to pass it to the procedure. we will unstack the copy when were done which
; should leave everything hunky dory.
; We will still have a problem if we ever come across a parameter with mode
; equal to OSUB because we dont know wether to release its body at CDALA time.

CNSPS3: CALL    TV,<$,OP>
        MOVE    1,O2P
        FGET    0,1,OM
        CAIE    0,OSUB
        J       CNSPS5
        CALL    CERRN,<^D45>
        ; THE FOLLOWING IS WHAT WE DID BEFORE WE  CAUGHT THE BAD MODE
        FGET    2,1,OL
        CAILE   2,15
        J       CNSPS5
;                       CNSPS 4
        MM      2,R
        J       CNSPS6
;                       CNSPS5
CNSPS5: CALL    FNDR,<1>,<R>
        CALL    LDS,<$,R,$,O2P>
;                       CNSPS 6  CNAY (BELOW) JUMPS IN HERE
CNSPS6:M 1,MODE
        CAIN    1,7
        J       CSPS12
;                       CNSPS 7
        M       1,R
        M       0,1
        HRLI    0,(MOVE @)
        DPB     1,ACZ
        CALL    GRI,<,0>
;                       CNSPS 8
        M       1,MODE
        CAIE    1,4
        J       CSPS10
;                       CNSPS 9  SFO
        M       0,[HRLI 0,^O740]      ; PUT IN THE SFO STRING TYPE CODE
        M       1,R
        DPB     1,ACZ
        CALL    GRI,<,0>

CSPS9A: MOVSI   0,(MOVEM)
        OR      0,LOK
        M       1,R
        DPB     1,ACZ
        CALL    GRI,<,UVAR>
        J       CSPS11
;                       CNSPS 10   CFO
CSPS10: MOVSI   0,(HRRM)
        OR      0,LOK
        M       1,R
        DPB     1,ACZ
        CALL    GRI,<,LVR>
;                       CNSPS 11
CSPS11: AOS     LOK
        CALL    OREM,<1>
        J       CSPS$$
;                       CNSPS 12   BLISS
CSPS12: M       0,R
        HRLI    0,(PUSH 15,)
        CALL    GRI,<,0>
        CALL    OREM,<1>
;                       EXIT CNSPS
CSPS$$: BRETURN CNSPS
        SUBTTL CNAY CALLF.6.7   PASS AN ARRAY
        BDCL    CNAY
;                       CNAY 1
        M       1,MODE
        CAIN    1,6             ; SIMPL?
        J       CNAY$$          ; YES, DONT DO ANYTHING
        CAILE   1,3
        J       CNAY3
;                       CNAY 2  TBA
        CALL    TV,<$,OP>
        CALL    GR1M
        MOVSI   0,(MOVEI 2,)
        OR      0,LOK
        CALL    GRI,<,$,REL>
        CALL    CXR,<RXAMX>
        M       1,PDTP
        FGET    2,1,PASN
        MOVE    1,.WSTCS(2)
        ADDI    1,1
        ADDM    1,LOK
        J       CNAY$$
;                       CNAY 3  NON-TBA
; see comment at CNSPS3
CNAY3:  CALL    TV,<$,OP>
        CALL    FNDR,<1>,<R>
        CALL    SVR,<$,R>
        CALL    GRM,<$,R,$,O2P>

;               CNAY 4
        MOVE    1,MODE
        CAIN    1,7
        JRST    CSPS12  ; GO HANDLE BLISS

;               CNAY 5
        MOVE    1,R
        MOVE    0,1
        HRLI    0,(MOVE @)
        DPB     1,ACZ
        CALL    GRI,<,0>

;               CNAY 6
        MOVE    1,MODE
        CAIE    1,4
        JRST    CSPS10  ; GO DO CFO

;               CNAY 7
        MOVE    1,TYP
        MOVSI   0,(HRLI 0,)
        HRR     0,SFOT(1)
        MOVE    1,R
        DPB     1,ACZ
        CALL    GRI,<,0>
        JRST    CSPS9A

;                       EXIT CNAY
CNAY$$: BRETURN CNAY
        SUBTTL QSAV CALLF.8     MOVE ALL TEMP CELLS TO A SAFE PLACE
        BDCL    QSAV

;                               QSAV 3
QSAV3:  MOVEI   1,1
        MM      1,WW

;                               QSAV 4-5-6
QSAV4:  MOVE    2,OPDN
        SUB     2,NPAR
        CAMLE   1,2
        JRST    QSAV11
        M       2,OPDL(1)
        MM      2,OP
        FGET    1,2,OM
        CAIN    1,OLVAR
        J       QSAV8
        CAIE    1,OREG
        J       QSAV10

;                               QSAV 7
        CALL    IMPOS

;                               QSAV 8
QSAV8:  M       2,OP
        FGET    1,2,OV
        JE      1,QSAV10

;                               QSAV 9
        CALL    SVTQ,<$,OP,$,r%vrlc>,<N>
        ADDM    1,r%vrlc

;                               QSAV 10
QSAV10: AOS     1,WW
        J       QSAV4

;                               EXIT QSAV
QSAV11: MOVE    1,MODE
        CAILE   1,3
        JRST    QSAV$$
        CALL    OREM,<$,NPAR>

QSAV$$: BRETURN QSAV
        SUBTTL CCFSI CALLF.24   GENERATE ARG. LIST FOR CFO OR SIMPL
        BDCL    CCFSI
;                       CCFSI 1
        SETZM   0,WW
        M       2,OPDN
        SUB     2,NPAR
        M       1,OPDL(2)
        MM      1,OP
        SETZM   R
        M       1,MODE
        CAIN    1,6
        AOS     R
;                       CCFSI 2
CCFSI2: M       1,WW
        CAML    1,NPAR
        J       CFSI$$
;                       CCFSI 3
        MOVEI   2,4
        ADDB    2,OP
        FGET    1,2,OT
        MM      1,TYP
;                       CCFSI 4
        M       1,MODE
        CAIE    1,5
        J       CFSI12
;                       CCFSI 5
        FGET    1,2,OC          ;OP IN R2 FROM BOX 3
        CAIE    1,ONSC
        J       CFSI10
;                       CCFSI 6
        FGET    1,2,OM          ;OP IN R2 FROM BOX 3
        CAIE    1,OLVAR
        J       CCFSI8
;                       CCFSI 7
        MI      1,LVR
        J       CCFSI9
;                       CCFSI 8
CCFSI8: MI      1,UVAR
;                       CCFSI 9
CCFSI9: FGET    0,2,OL          ;OP IN R2 FROM BOX 3
        J       CFSI11
;                       CCFSI 10
CFSI10: SETZB   0,1
;                       CCFSI 11
CFSI11: HRLI    0,(JUMP)
        M       3,TYP
        M       2,CFOT(3)
        DPB     2,ACZ
        CALL    GRI
        J       CFSI18
;                       CCFSI 12
CFSI12: FGET    1,2,OC          ;OP IN R2 FROM BOX 3
        CAIN    1,OSSC
        J       CFSI14
        CAIN    1,OMX
        J       CFSI15
;                       CCFSI 13
        CALL    LDR,<$,R,$,OP>
        M       1,TYP
        M       0,WDSIZ(1)
        ADDM    0,R
        J       CFSI16
;                       CCFSI 14
CFSI14: CALL    LDS,<$,R,$,OP>
        AOS     R
        J       CFSI16
;                       CCFSI 15
CFSI15: CALL    SVR,<$,R>
        CALL    GRM,<$,R,$,OP>
        AOS     R
;                       CCFSI 16
CFSI16: M       1,R
        CAIG    1,10
        J       CFSI18
;                       CCFSI 17   error: simpl routine has too many parameters
        CALL    CERR,<38>
;                       CCFSI 18
CFSI18: AOS     WW
        J       CCFSI2
;                       EXIT CCFSI
CFSI$$: BRETURN CCFSI
        SUBTTL CSTAK CALLF.29  STAK THE RESULT OF THE PROCEDURE
        BDCL    CSTAK
;                       CSTAK 1
        M       1,SDTP
        FGET    0,1,STYP
        MM      0,TYP
;                       CSTAK 1B
        SKIPE   FDIM
        J       CSTK15
;                       CSTAK 2
        CAIE    0,STR
        J       CSTAK6
;                       CSTAK 3
        SKIPE   RFLG
        J       CSTAK5
;                       CSTAK 4
        M       0,SAD
        HRLI    0,(MOVEI 2,)
        CALL    GRI,<,UVAR>
        CALL    CXR,<RXPSS>
        CALL    TQFRE,<$,SRN>
        J       CSTK$$
;                       CSTAK 5
CSTAK5: CALL    TVF,<OSSC,OTMP,STR,$,SAD,$,SRN,0>
        J       CSTK$$
;                       CSTAK 6
CSTAK6: SKIPN   RFLG
        JRST    CSTK$$
;                       CSTAK 7
        MOVE    4,MODE
        M       0,EREG(4)
        MM      0,R
        CALL    TVR,<,$,TYP>
;                       CSTAK 8
        M       1,TYP
        CAIN    1,DBL
        J       CSTK13
        CAIE    1,LOG
        J       CSTK$$
;                       CSTAK 9
        M       1,MODE
        CAIG    1,3
        J       CSTK$$
        CAIE    1,7
        J       CSTK11
;                       CSTAK 10
        M       0,[TRNN 0,1]
        M       1,R
        DPB     1,ACZ
        CALL    GRI,<,0>
        MOVSI   0,(SETZ)
        M       1,R
        DPB     1,ACZ
        CALL    GRI,<,0>
        M       0,[TRNE 0,1]
        M       1,R
        DPB     1,ACZ
        CALL    GRI,<,0>
        J       CSTK12
;                       CSTAK 11
CSTK11: M       0,R
        HRLI    0,(SKIPE)
        CALL    GRI,<,0>
;                       CSTAK 12
CSTK12: M       0,[MOVEI 0,1]
        M       1,R
        DPB     1,ACZ
        CALL    GRI,<,0>
        J       CSTK$$
;                       CSTAK 13
CSTK13: M       1,MODE
        CAIE    1,5
        J       CSTK$$
;                       CSTAK 14
        M       0,[LSH 1,9]
        CALL    GRI,<,0>
        J       CSTK$$
;                       CSTAK 15
CSTK15: SKIPE   RFLG
        J       CSTK20
;                       CSTAK 16
        M       0,SAD
        MI      1,UVAR
;                       CSTAK 17
        M       2,TYP
        CAIE    2,STR
        J       CSTK19
;                       CSTAK 18
        HRLI    0,(MOVEI 1,)
        CALL    GRI
        CALL    CXR,<RSMREL>
        JRST    CSK19A
;                       CSTAK 19
CSTK19: HRLI    0,(MOVE 1,)
        CALL    GRI
        CALL    CXR,<RELSP>
CSK19A: CALL    TQFRE,<$,SRN>
        J       CSTK$$
;                       CSTAK 20
CSTK20: CALL    TVF,<OMX,OTMP,$,TYP,$,SAD,$,SRN,$,FDIM>
;                       EXIT CSTAK
CSTK$$: BRETURN CSTAK
        SUBTTL CDALA CALLF.31 DO SOME STUFF FOR EXTERNAL PROCEDURES
        BDCL    CDALA

        SALL

;                       CDALA 0
        MOVE    0,MODE
        CAIN    0,7
        JRST    [  MOVE    1,NPAR
        HRL     1,NPAR
        CALL    CLIT,<INT>
        MOVSI   0,(SUB 15,)
        HRR     1,2             ; AC2 CONTAINS FXADR FROM CLIT
        CALL    GRJ
        JRST    .+1 ]
;                       CDALA 1
        SETZM   0,WW
        M       2,OPDN
        SUB     2,NPAR
        SUB     2,RFLG
        M       1,OPDL(2)
        MM      1,OP
;                       CDALA 2
CDALA2: M       2,WW
        CAML    2,NPAR
        J       CDLA11
;                       CDALA 3
        MOVEI   1,4
        ADDB    1,OP
;                       CDALA 4   IF OP/OM = OTMP AND ITS A STRING OR AN ARRAY
;                                 THEN WE WANT TO FREE THE BODY. IF OP/OM =
;                                 OKON OR OUVAR THEN WE DONT. IF OP/OM = SOMTHING
;                                 ELSE THEN WE DONT KNOW WHAT TO DO
        FGET    0,1,OM
        CAIE    0,OTMP
        JRST    CDLA10
        FGET    0,1,OC
        CAIN    0,OMX
        JRST    CDALA6
        CAIE    0,OSSC
        JRST    CDLA10
;                       CDALA 5
        CALL    SAVREG
        CALL    LDS,<1,$,OP>
        J       CDALA8
;                       CDALA 6
CDALA6: CALL    SAVREG
        MOVE    1,OP
        FGET    0,1,OL
        HRLI    0,(MOVE 1,)
        CALL    GRI,<,LVR>
;                       CDALA 7
        M       1,OP
        FGET    0,1,OT
        CAIN    0,STR
        J       CDALA9
;                       CDALA 8
CDALA8: CALL    CXR,<RELSP>
        J       CDLA10
;                       CDALA 9
CDALA9: CALL    CXR,<RSMREL>
;                       CDALA 10
CDLA10: AOS     WW
        J       CDALA2
;                       CDALA 11
CDLA11: M       1,OPDN
        ADDI    1,1
        SUB     1,RFLG
        CALL    ONUL,<$,NPAR>
;                       EXIT CDALA

        XALL
        BRETURN CDALA
        SUBTTL CSRRG  SAVE OR RESTORE REGISTERS 12,13,14 DECIMAL

;  procedure csrrg(svflg,lok)

;  ! Saves or restores (as svflg = 1 or 0) registers 12,13,14 decimal
;  ! beginning at location lok.  Returns lok+3, the next available
;  ! location.

;  gri([(if svflg then dmovem else dmove) 12,lok],uvar)
;  gri([(if svflg then movem else move) 14,lok+2],uvar)
;  return lok+3

;  end csrrg



        dcl     csrrg,<SVFLG,LOK>

        movsi   0,(dmovem 12,)
        skipn   svflg
        movsi   0,(dmove 12,)
        hrr     0,lok
        call    gri,<,uvar>

        movsi   0,(movem 14,)
        skipn   svflg
        movsi   0,(move 14,)
        hrr     0,lok
        addi    0,2
        call    gri,<,uvar>

        move    1,lok
        addi    1,3
        return  csrrg,<>
        SUBTTL CERR   PRINT ERROR MESSAGE AND RESUME
        DCL     CERR,<N>

;                               CERR 1
        SKIPE   DSFLG
        J       CERR3

;                       CERR 2
        CALL    PREL

;                       CERR 3
CERR3:  AOS     CERCNT
        CALL    OREM,<$,OPDN>
        CALL    TQCLR
        SETZM   0,RGSV
        M       2,[RGSV,,RGSV+1]
        BLT     2,RGSV+10
        M       1,N
        CALL    CXR2,<$,CMSG(1),MONOCR>

;                               CERR 2
        CALL    RZUM
        SUBTTL CERRN   PRINT ERROR MESSAGE WITH NAME AND RESUME
        DCL     CERRN

;                               CERRN 1
        CALL    CNERR
        CALL    OREM,<$,OPDN>
        CALL    TQCLR

;                               CERRN 2
        CALL    RZUM
        SUBTTL CEXIT  EXIT FROM A PROCEDURE, RETURN A NULL VALUE
        DCL     CEXIT,,<SDTP,PROP>

;                               CEXIT 1
        CALL    EXCK,,<SDTP,PROP>

;                               CEXIT 2
        FGET    R0,R2,PFDIM
        JUMPN   R0,CEXIT3       ; an array-valued procedure

;A scalar-valued procedure. Check type:

        FGET    R0,R1,STYP
        CAIN    R0,STR
        JRST    CEXIT4

;Numeric scalar:

        CALL    GRI,<$,<[SETZB R0,R1]>,ABS>
        JRST    CEXIT7

;String scalar:

CEXIT4: FGET    R0,R1,SLOC
        HRLI    R0,(MOVE R1,)
        CALL    GRI,<,UVAR>
        HRLZI   R0,(SETZM @(R1))
        CALL    GRI,<,ABS>      ; zero the caller's string descriptor
        JRST    CEXIT5

;Array-valued procedure, type inconsequential:

CEXIT3: FGET    R0,R1,SLOC
        HRLI    R0,(MOVE R1,)
        CALL    GRI,<,UVAR>     ; get rtn addr
        MOVE    R0,[MOVE R1,(R1)]
        CALL    GRI,<,ABS>      ; get loc of caller's array descriptor
        MOVE    R0,[SETZM .aloc(R1)]
        CALL    GRI,<,ABS>      ; zero the first word of his descrptr
        CALL    TVKI,<$,<[ERROR ME15]>> ;Reference to undeclared array
        CALL    GRO,<O(MOVE),R2,$,O2P>
        CALL    OREM,<1>        ; unstack the operand literal
        MOVE    R2,PROP
        FGET    R1,R2,PFDIM
        MOVE    R0,.cadr(R1)    ; access code offset
        HRLI    R0,(MOVEM R2,(R1))
        CALL    GRI,<,ABS>      ; stick error uuo into first word of access code of caller's descriptor

CEXIT5: MOVE    R1,SDTP         ; for arrays and string scalars, inc return address
        FGET    R0,R1,SLOC
        HRLI    R0,(AOS)
        CALL    GRI,<,UVAR>

CEXIT7: CALL    EXDR,<$,SDTP,$,PROP>

;                               EXIT CEXIT
        RETURN  CEXIT
        SUBTTL CHFXP    FIXUP ADR WITH CURRENT LOC
        DCL     CHFXP,<ADRS>

;                               CHFXP 1
        JE      0,CFXP$$

;                               CHFXP 2
        skipe   relflg##        ; rel file requested?
        jrst    chfxp4          ; no
        scall   r%rfix,<$,adrs,rlcode,$,r%cdlc,$,r%cdrl>


;                       CHFXP 4   are we doing a CDE
CHFXP4: SKIPG   CDEFLG
        J       CFXP$$

;                       CHFXP 5   print   loc  FIXUP  adrs
        CALL    CXTDO,<13>
        CALL    CXTDO,<10>
        CALL    OPNM,<$,r%cdlc>
        M       0,SGNAM+3
        CALL    TDO,<,MONOCR>
        CALL    OPNM,<$,ADRS>

;                               EXIT CHFXP
CFXP$$: RETURN  CHFXP
        SUBTTL CJMP      COMPIL CODE FOR CONDITIONAL BRANCH
        DCL     CJMP,<OP1,OP2,REL>,<OXP,OYP,RGX>

;                               CJMP 1
        M       2,OP2
        FGET    1,2,OM
        CAIE    1,OKON
        J       CJMP2
        FGET    1,2,OV
        JE      1,CJMP4

;                               CJMP 2
CJMP2:  M       2,OP1
        FGET    1,2,OM
        CAIE    1,OKON
        J       CJMP5
        FGET    1,2,OV
        JN      CJMP5

;                               CJMP 3
        M       1,OP2
        MM      1,OP1
        SETZM   OP2
        M       1,REL
        M       2,RLRV(1)
        MM      2,REL
        J       CJMP5

;                               CJMP 4
CJMP4:  SETZM   OP2

;                                       CJMP 5
CJMP5:  SKIPE   OP2
        J       CJMP10

;                               CJMP 6
        M       2,OP1
        FGET    1,2,OM
        CAIN    1,OREG
        J       CJMP8
        CAIE    1,OKON
        J       CJMP9

;                               CJMP 7
        CALL    LD,<$,OP1>,<RGX>
        MOVSI   0,(JUMP)
        M       1,RGX
        DPB     1,ACZ
        M       1,REL
        DPB     1,RELZ
        SETZ    1,0
        CALL    GRI
        J       CJMP$$

;                               CJMP 8
CJMP8:  M       2,OP1
        FGET    1,2,OL
        MOVSI   0,(JUMP)
        DPB     1,ACZ
        M       1,REL
        DPB     1,RELZ
        SETZ    1,0
        CALL    GRI
        J       CJMP$$

;                               CJMP 9
CJMP9:  M       1,REL
        M       0,RLNG(1)
        ADDI    0,O(SKIP)
        CALL    GRNT,<,0,$,OP1>
        CALL    JMP,<0>
        J       CJMP$$

;                               CJMP 10
CJMP10: CALL    CZLD,<$,OP1,$,OP2>,<OXP,OYP,RGX>

;                               CJMP 11
        M       1,OXP
        CAMN    1,OP1
        J       CJMP13

;                               CJMP 12
        M       1,REL
        M       2,RLRV(1)
        MM      2,REL

;                               CJMP 13
CJMP13: CALL    CMP,<$,RGX,$,OYP,$,REL>
        CALL    JMP,<0>

;                               EXIT CJMP
CJMP$$: RETURN  CJMP
        SUBTTL CKC  CHECK CLASS OF OPERAND, GIVE ERROR IF NOT RIGHT
        DCL     CKC,<OP,COC>

;                               CKC 1
        M       2,OP
        FGET    1,2,OC
        CAMN    1,COC
        J       CKC$$

;                               CKC 2
        CALL    CERR,<22>

;                               EXIT CKC
CKC$$:  RETURN  CKC
        SUBTTL CKLVA

; program logic for cklva

; cklva generates code to set up in register 1 a pointer to the variable,
; array, array element or slice to be stored into by a READ, INPUT, or
; EIGHTI statement.

;  procedure cklva

;  local sdtp, id       ! getid and tvid use these and I don't know what they are.
;  register ins=0       ! instruction to be sent to gri
;  register seg=1       ! segment number for same

;  [sdtp;id] := getid()
;  if sdtp#0 and sdtp.sknd=spro then cerrn(27,id)
;  tvid(sdtp,id)

;  eif o2p.oc=omx then
;    grm(1,o2p)  ! generate code for array or array slice

;  else
;    do  ! scalar of some kind or another
;    ins := [movei 1,o2p.ol];  seg := lvr
;    eif o2p.om=osub then
;      [ins := [hrrz 1,o2p.ol];  seg := abs]
;    fif o2p.om=ouvar then
;      seg := uvar
;    gri(ins,seg)
;    end

;  end cklva

        SALL

; code for cklva

        dcl     cklva

        call    getid           ; [r1;r2] := getid()

        jumpn   1,[fget 3,1,sknd
        caie    3,spro          ; if r1#0 and r1.sknd=spro then cerrn(27,r2)
        jrst    .+1
        movei   0,27
        move    1,2
        call    cerrn
        jrst    .+1  ]

        move    0,1
        move    1,2
        call    tvid            ; tvid(r1,r2)

        move    3,o2p
        fget    0,3,oc
        cain    0,omx           ; eif o2p.oc=omx then
        jrst    [  call grm,<1,$,o2p>
        jrst    cklv$$  ]

        fget    0,3,ol          ; else do
        hrli    0,(movei 1,)    ; ins := [movei 1,o2p.ol]
        movei   1,lvr           ; seg := lvr

        fget    2,3,om          ; r2 := o2p.om

        cain    2,osub          ; eif r2=osub then
        jrst    [  hrli 0,(hrrz 1,); ins := [hrrz 1,o2p.ol]
        movei   1,abs           ; seg := abs
        jrst    cklv1  ]

        cain    2,ouvar         ; fif r2=ouvar then
        movei   1,uvar          ; seg := uvar

cklv1:
        call    gri             ; gri(ins,seg)

cklv$$:
        return  cklva

        XALL
        SUBTTL CKN1  MAKE SURE OPERAND IS A 1 WORD NUMERIC SCALER
        DCL     CKN1,<OP>

;                               CKN1 1
        CALL    CKC,<$,OP,ONSC>
        CALL    CKNT,<$,OP,CMPLX>
        CALL    CKNT,<$,OP,DBL>

;                               EXIT CKN1
        RETURN  CKN1
        SUBTTL CKND
        DCL     CKND,<OP,N>

;                       CKND 1
        M       2,OP
        FGET    1,2,ONG
        CAMN    1,N
        J       CKND$$
        M       3,N
        CAIN    3,11
        J       CKND$$
        CAIN    1,11
        J       CKND$$

;                               CKND 2
        CALL    CERR,<31>

;                               EXIT CKND
CKND$$: RETURN  CKND
        SUBTTL CKNT  MAKE SURE OPERAND IS NOT OF TYPE T
        DCL     CKNT,<OP,T>

;                               CKNT 1
        M       2,OP
        FGET    1,2,OT
        CAME    1,T
        J       CKNT$$

;                               CKNT 2
        CALL    CERR,<14>

;                               EXIT CKNT
CKNT$$: RETURN  CKNT
        SUBTTL CKT  MAKE SURE OPERAND IS OF TYPE T
        DCL     CKT,<OP,T>

;                               CKT 1
        M       2,OP
        FGET    1,2,OT
        CAMN    1,T
        J       CKT$$

;                               CKT 2
        CALL    CERR,<14>

;                               EXIT CKT
CKT$$:  RETURN  CKT
;               LITERALS (LIT,SLIT,LHSH)

; There are three tables used for handeling literals. The LIT table holds
; the type and fixup adr of the literals. It also holds the actual literal for
; numeric scaler literals, or a pointer into the SLIT table for string literals.

; The SLIT table holds the actual string literals. A hash table ,LHSH ,
; holds hash codes for every LIT table entry and is used for literal pooling.
; Each record in LHSH is  a block of LBSZE hashes. This was done to avoid a lot
; of TLOCs when searching for literals.( a similar scheme was used for temp cells)

;  Numeric scaler constants are carried on the operand stack untill they are
; referenced. At that point, the routine CLIT is called which will search the
; LIT table, with the aid of the LHSH table, for a matching literal. If no
; match is found, a new LIT record is created for the literal. When a string
; constant is encountered, CLIT is again called to find a match. If no match
; is found, a LIT record is created and the string is stored in the SLIT table.
; The fixup adress is not filled in untill the string is first referenced. The
; operand stack entry for the string carries the LIT record number in the /OL
; field.

; When compilation is completed, literals are deposited in the routine DPLIT.
               SUBTTL  LBGET   GET A LITERAL HASH BLOCK
        DCL     LBGET,<BP>

        MOVEM   0,LBPNT

        CALL    TLOC,<$,LHSH,$,BP>,<LHSHP>

        MOVEI   0,LITBLK
        HRL     0,LHSHP
        MOVEI   1,LITBLK
        BLT     0,LBSZE-1(1)

        MOVE    1,LHSHP
        CALL    RCLN

        RETURN  LBGET


        SUBTTL  LBREL  RELEASE A LITERAL HASH BLOCK
        DCL     LBREL,<BP>

        CALL    TLOC,<$,LHSH,$,BP>,<LHSHP>

        MOVE    0,LHSHP
        HRLI    0,LITBLK
        MOVE    1,LHSHP
        BLT     0,LBSZE-1(1)

        MOVE    R1,LHSHP
        CALL    RDTY

        RETURN  LBREL


        SUBTTL  NXTLB    GET  THE NEXT LITERAL HASH BLOCK
        DCL     NXTLB

        CALL    LBREL,<$,LBPNT>
        AOS     LBPNT
        CALL    LBGET,<$,LBPNT>

        RETURN  NXTLB

        SUBTTL  GETLB1  GET LITERAL HASH BLOCK #1
        DCL     GETLB1

        MOVE    0,LBPNT
        CAIN    0,1
        JRST    GTLB$$

        SKIPE   ,0
        CALL    LBREL

        CALL    LBGET,<1>

GTLB$$: RETURN  GETLB1


               SUBTTL CLIT   CREATE A LITERAL, AFTER FIRST LOOKING FOR A MATCHING LIT
        DCL     CLIT,<LOT,LOV,LOL>,<LITP,HSH,SAVER1,N,FXADR>
;*** FIRST WE HASH OUR LITERAL


;                       CLIT 0  HASH THE LITERAL
        MOVE    2,LOT
        CAIE    2,STR           ; TYPE=STRING?
        JRST    CLIT0A

        MOVEI   1,MBUFD         ; YES, HASH STRING
        FGET    1,1,SDCL
        IDIVI   1,5
        MOVE    0,MSKTBL(2)
        ANDM    0,MBUF(1)
        EQV     2,MBUF(1)
        SOJGE   1,.-1
        MOVEM   2,HSH
        JRST    CLIT0B

CLIT0A: MOVE    0,LOV           ; HERE WE HASH NUMERIC SCALERS
        MOVEM   0,HSH
        MOVE    1,LOL
        CAIL    2,DBL           ; IS THIS A TWO WORD CONSTANT?
        EQVM    1,HSH


CLIT0B: SKIPN   ,HSH
        SETOM   ,HSH            ; NOTHING IS ALLOWED TO HASH TO ZERO
        CALL    GETLB1


;*** THEN WE SEARCH FOR A MATCHING LITERAL

;                       CLIT 1-2  SEARCH FOR A MATCHING LITERAL
CLIT1:  SETZ    1,
        MOVE    0,HSH
CLIT2:  MOVE    2,LITBLK(1)
        CAMN    0,2             ; IF HASHES MATCH, CHECK FOR A COMPLETE MATCH
        JRST    CLIT3
        JUMPE   2,CLIT4         ; IF OUT OF HASHES TO LOOK AT, GO MAKE A NEW LIT
CLIT2A: AOJ     1,
        CAIGE   1,LBSZE         ; ANY MORE IN THIS BLOCK?
        JRST    CLIT2           ;  YES, CONTINUE LOOKING
                                ;       NO, GET NEXT BLOCK
        CALL    NXTLB
        JRST    CLIT1



;                       CLIT 3  THE HASHES MATCH
CLIT3:  MOVEM   1,SAVER1
        MOVEI   2,LBSZE         ; FROM THE BLOCK # AND THE LOC IN BLOC GET THE REC #
        IMUL    2,LBPNT
        SUBI    2,LBSZE-1
        ADD     1,2             ; (LBPNT-1)*LBSZE + c(r1) +1 -> r1
        CALL    TLOC,<$,LIT>,<LITP,N>

        FGET    3,1,LTYP
        CAME    3,LOT           ; IF THE TYPES DONT MATCH, THE LITS DONT MATCH
        JRST    CLIT3D          ; WE ARE NOT GOING TO MESS WITH POOLING THINGS
                                ; OF DIFF TYPES THAT HAPPEN TO MATCH

        MOVE    0,LOT
        CAIN    0,STR           ; LOT = STR ?
        JRST    CLIT3B          ;  YES, GO COMPARE STRINGS

                                ;       HERE WE COMPARE NUMERIC SCALERS
        FGET    3,1,LV
        CAME    3,LOV
        JRST    CLIT3D          ;  NO, THEY DONT MATCH. GO LOOK AT ANOTHER

        CAIGE   0,DBL           ; LOT = DBL OR COMPLEX?
        JRST    CLIT3A          ;   NO, WE ALREDY HAVE A MATCH THEN
        FGET    3,1,LL
        CAME    3,LOL
        JRST    CLIT3D          ;   THEY DONT MATCH, GO LOOK AT ANOTHER

CLIT3A: FGET    0,1,LADR        ; LITP.LADR -> FXADR
        MOVEM   0,FXADR
        MOVE    0,R%CDLC        ; R%CDLC -> LITP.LADR
        FPUT    0,1,LADR
        JRST    CLIT6


                                ;       HERE WE COMPARE STRINGS
CLIT3B: FGET    2,1,LL          ; LITP.LL HOLDS VIRTUAL ADR  OR ZERO FOR NULL STRING
        HRRZS   CLITB+1         ; 0-> CLITB+1lh
        JUMPE   2,CLT3BB
        CALL    VGET,<CLITB,$,SLIT>

CLT3BB: MOVEI   1,CLITB
        MOVEI   2,MBUFD
        FGET    3,1,SDCL        ; GET DECLARED LENGTH OF PREVIOUS LITERAL
        FGET    4,2,SDCL        ; GET DECLARED LENGTH OF NEW LITERAL
        CAME    3,4             ; DO THEY MATCH?
        JRST    CLIT3D          ;   NO, GO LOOK AT ANOTHER

        IDIVI   3,5             ; # OF COMPLETE WORDS IN R3, # OF EXCESS CHARS IN R4
        MOVE    0,MSKTBL(4)     ; WERE GOING TO MASK OUT INVALID CHARS
        ANDM    0,CLITBF(3)     ; LAST WORD OF PRVIOUS LITERAL
        ANDM    0,MBUF(3)       ; LAST WORD OF NEW LITERAL

CLIT3C: MOVE    0,CLITBF(3)
        CAME    0,MBUF(3)
        JRST    CLIT3D          ; THEY DONT MATCH , GO LOOK AT ANOTHER
        SOJGE   3,CLIT3C

        JRST    CLIT6           ; THEY MATCH, WE RETURN WITH N POINTING TO THE LITERAL

CLIT3D: MOVE    R1,LITP
        CALL    RCLN
        MOVE    1,SAVER1        ; IT WASNT A COMPLETE MATCH
        MOVE    0,HSH
        JRST    CLIT2A




;                       CLIT 4  NO MATCH WAS FOUND, MAKE A NEW LITERAL
CLIT4:  MOVEM   0,LITBLK(1)     ; WE MAKE A NEW LITERAL
        CALL    TNEW,<$,LIT>,<LITP,N>
        MOVE    0,LOT
        FPUT    0,1,LTYP        ; LOT -> LITP.LTYP
        CAIN    0,STR
        JRST    CLIT5
        MOVE    0,R%CDLC        ; NO, R%CDLC -> LITP.LADR
        FPUT    0,1,LADR
        MOVE    0,LOV
        FPUT    0,1,LV
        MOVE    0,LOL
        FPUT    0,1,LL
        SETZM   ,FXADR          ; RETURN ZERO, MARKS END OF FIXUP CHAIN
        JRST    CLIT6

                                ;       YES, ITS A STRING
CLIT5:  CALL    VPUT,<MBUFD,$,SLIT>
        MOVE    2,LITP          ; VPUT RETURNS VIRT. ADR. OF FIRST WORD, OR ZERO FOR NULL STRINGS
        FPUT    1,2,LL          ; PUT VIRTUAL ADR IN LITP.LL

CLIT6:  MOVE    R1,LITP
        CALL    RDTY

CLIT$$: RETURN  CLIT,<$,N,$,FXADR>

MSKTBL: 0
        BYTE    (7) ^O177
        BYTE    (7) ^O177,^O177
        BYTE    (7) ^O177,^O177,^O177
        BYTE    (7) ^O177,^O177,^O177,^O177

        SUBTTL CMP  GENERATE A COMPARISON

;  procedure cmp(rgx,oyp,rel)

;  ! Generates code to execute the next instruction generated only if the
;  ! relation rel is true between the values in rgx and oyp.  Rgx is a
;  ! register number, oyp is an operand pointer (opdstk).
;  ! The two operands must be the same type, which can be integer, real,
;  ! or double precision.  No complex or strings!  I guess logical is OK.

;  ! Values allowed for rel and their meanings:

;  ! 1 <    2 =    3 <=    5 >=    6 #    7 >

;  ! These are the same values used in PDP10 test instructions, e.g. a CAMGE
;  ! instruction is a CAM instruction with 5 in the mode field (see PDP10
;  ! System Reference Manual).

;  ! For integer and real values, we generate a CAI or CAM instruction
;  ! with the opposite of rel in the mode field (we want to NOT skip if
;  ! the relation is true).  The array rlng provides the opposite relation.

;  ! Double precision is a little more complicated.  The code
;  ! generated is as follows, and is taken from Fortran-10.  R is the first
;  ! register of the rgx value, and M is the first memory location of the
;  ! oyp value.

;  ! rel           code generated

;  ! 1  r<m        camn r,m
;  !               caml r+1,m+1
;  !               camge r,m

;  ! 2  r=m        camn r,m
;  !               came r+1,m+1
;  !               skipa

;  ! 3  r<=m       camn r,m
;  !               camle r+1,m+1
;  !               camge r,m

;  ! 5  r>=m       camn r,m
;  !               camge r+1,m+1
;  !               camle r,m

;  ! 6  r#m        camn r,m
;  !               came r+1,m+1

;  ! 7  r>m        camn r,m
;  !               camg r+1,m+1
;  !               camle r,m

;  ! PLM code for cmp:

;  register t=0    ! Just a temp

;  ! Opcodes for the second instruction of a double precision compare:
;  table cpdb1(0:7) [o(halt),  o(caml),  o(came),  o(camle),
;                    o(halt),  o(camge), o(came),  o(camg)]

;  ! Opcodes for the third instruction of a double precision compare:
;  ! (0 means generate nothing, 1 means generate skipa)
;  table cpdb2(0:7) [o(halt),  o(camge), -1,       o(camge),
;                    o(halt),  o(camle), 0,        o(camle)]

;  eif oyp.ot=dbl or oyp.ot=cmplex then
;    do  ! Double precision
;    grnt(o(camn),rgx,oyp)
;    grnt2(cpdb1[rel],rgx+1,oyp)
;    t := cpdb2(rel)
;    eif t<0 then gri([skipa],0)
;    fif t>0 then grnt(t,rgx,oyp)
;    end

;  else
;    do  ! Integer, real
;    t := rlng[rel]  ! Opposite of the specified relation
;    eif tim(oyp)=0 then  ! tim tells if immediate instruction is ok
;      gr(o(cai)+t,rgx,0,0,oyp.ov,0)
;    else
;      grnt(o(cam)+t,rgx,oyp)
;    end

;  end cmp

        SALL

        dcl     cmp,<RGX,OYP,REL>

        move    3,oyp
        fget    0,3,ot
        caige   0,dbl           ; eif oyp.ot=dbl or oyp.ot=cmplx then
        jrst    cmp1

        call    grnt,<o(camn),$,rgx,$,oyp>

        move    1,rel
        move    0,cpdb1(1)
        move    1,rgx
        addi    1,1
        move    2,oyp
        call    grnt2           ; grnt2(cpdbl1[rel],rgx+1,oyp)

        move    1,rel
        move    0,cpdb2(1)      ; r0 := cpdb2[rel]

        jumpl   0,[movsi 0,(skipa)
        movei   1,0             ; eif r0<0 then gri([skipa],0)
        call    gri
        jrst    cmp$$  ]

        jumpg   0,[move 1,rgx
        move    2,oyp
        call    grnt            ; fif r0>0 then grnt(r0,rgx,oyp)
        jrst    cmp$$  ]

        jrst    cmp$$           ; r0=0 generates nothing

cmp1:
        call    tim,<$,oyp>

        move    2,rel
        move    0,rlng(2)       ; r0 := rlng[rel], preserving value of tim in r1

        jumpe   1,[addi 0,o(cai)  ; eif tim(oyp)=0 then
        move    1,rgx
        setzb   2,3
        move    4,oyp
        fget    4,4,ov
        movei   5,0
        call    gr              ; gr(o(cai)+r0,rgx,0,0,oyp.ov,0)
        jrst    cmp$$  ]

        addi    0,o(cam)        ; else
        move    1,rgx
        move    2,oyp
        call    grnt            ; grnt(o(cam)+r0,rgx,oyp)

cmp$$:
        return  cmp


cpdb1:  exp     o(halt),o(caml),o(came),o(camle),o(halt),o(camge),o(came),o(camg)

cpdb2:  exp     o(halt),o(camge),-1,o(camge),o(halt),o(camle),0,o(camle)
        XALL
        SUBTTL CNVRT   CONVERT OPERAND TYPE
        DCL     CNVRT,<OP,NT>,<OPT,OPM,OPV,OPL,RGY>

;                               CNVRT 1
        M       2,OP
        FGET    1,2,OC
        CAIN    1,ONSC
        J       CNVRT3

;                               CNVRT 2  ERROR 'NUMERIC SCALAR EXPECTED'
        CALL    CERR,<^D41>

;                               CNVRT 3
CNVRT3: M       2,OP    ; OP/OT =: OPT
        FGET    1,2,OT
        MM      1,OPT
        FGET    1,2,OM
        MM      1,OPM   ; OP/OM =: OPM
        FGET    1,2,OV
        MM      1,OPV   ; OP/OV =: OPV
        FGET    1,2,OL
        MM      1,OPL   ; OP/OL =: OPL

;                               CNVRT 4
        M       1,OPT
        CAMN    1,NT
        J       CVRT$$  ; IF THE OPERANDS THE RIGHT TYPE, THEN WE ARE DONE
        CAIE    1,STR   ; IF ITS A STRING THEN WE GIVE AN ERROR
        J       CNVRT6

;                               CNVRT 5  ERROR 'NUMERIC/STRING INCOMPATIBLITY'
        CALL    CERR,<^D39>

;                               CNVRT 6
CNVRT6: M       1,OPM
        CAIN    1,OKON
        J       CVRT10

;                               CNVRT 7
        M       1,NT
        CAIN    1,LOG
        J       CNVRT9

;                               CNVRT 8   CONVERT TO SCALAR
        BCALL   CNVSC
        J       CVRT11

;                               CNVRT 9    CONVERT TO LOGICAL
CNVRT9: BCALL   CNVTL
        J       CVRT11

;                               CNVRT 10   CONVERT A CONSATANT
CVRT10: BCALL   CNVK

;                               CNVRT 11
CVRT11: M       1,NT
        M       2,OP    ; OP/OT := NT
        FPUT    1,2,OT

;                               EXIT CNVRT
CVRT$$: RETURN  CNVRT
        SUBTTL CNVSC CNVRT.7  CONVERT NON CONSTANT TO SCALER TYPE
        BDCL    CNVSC

;                               CNVSC 1
        M       1,OPT
        CAIN    1,DBL
        J       CNVSC3
        CAIN    1,INT
        J       CNVSC2
        CAIE    1,LOG
        J       CNVSC4

;                               CNVSC 2
CNVSC2: BCALL   CNVI
        J       CVSC$$

;                               CNVSC 3
CNVSC3: BCALL   CNVD
        J       CVSC$$

;                               CNVSC 4
CNVSC4: M       1,NT
        CAIE    1,INT
        J       CNVSC6

;                               CNVSC 5
        BCALL   CNVTI
        J       CVSC$$

;                               CNVSC 6
CNVSC6: M       1,OPT
        CAIE    1,REAL
        J       CNVSC9

;                               CNVSC 7
        CALL    FND2R,<$,OP>,<OPL>
        CALL    LDR,<$,OPL,$,OP>

;                               CNVSC 8
        M       1,OPL
        ADDI    1,1
        MOVSI   0,(SETZ)
        DPB     1,ACZ
        SETZ    1,0
        CALL    GRI
        M       1,OPL
        M       2,RGSV(1)
        MM      2,RGSV+1(1)
        J       CVSC$$

;                               CNVSC 9
CNVSC9: BCALL   CNVC

;                               EXIT CNVSC
CVSC$$: BRETURN CNVSC
        SUBTTL CNVI CNVRT.7.2 CONVERT LOGICAL TO INTEGER TO A HIGHER TYPE
        BDCL    CNVI

;                               CNVI 1
        M       1,NT
        CAIN    1,INT
        J       CNVI$$

;               CNVI 2 NT USED FROM BOX 1 R1
        CAIN    1,DBL
        J       CNVI6
        CAIN    1,CMPLX
        J       CNVI9

;                               CNVI 3
        M       1,OPM
        CAIN    1,OREG
        J       CNVI5

;                               CNVI 4
        CALL    FNDR,<1>,<OPL>
        CALL    SVR,<$,OPL>

;                               CNVI 5
CNVI5:  CALL    GRNT,<O(FLTR),$,OPL,$,OP>
        J       CNVI11

;                               CNVI 6
CNVI6:  CALL    FND2R,<$,OP>,<OPL>
        CALL    LDR,<$,OPL,$,OP>
        SETZM   0,OPV
;                       CNVI 7
        MOVSI   0,(SETZ)
        M       1,OPL
        ADDI    1,1
        DPB     1,ACZ
        CALL    GRI,<,0>
        MOVSI   0,(JUMPE)
        M       1,OPL
        DPB     1,ACZ
        HRR     0,r%cdlc
        ADDI    0,5
        CALL    GRI,<,LOC>
        M       0,[ASHC 0,-9]
        M       1,OPL
        DPB     1,ACZ
        CALL    GRI,<,0>
        M       0,[TLOE 0,^O244000]
        M       1,OPL
        DPB     1,ACZ
        CALL    GRI,<,0>
        M       0,[TLZ 0,^O244000]
        M       1,OPL
        DPB     1,ACZ
        CALL    GRI,<,0>
;                       CNVI 8
        CALL    TVF,<ONSC,OKON,DBL,0,0,0>
        CALL    GRNT,<O(DFAD),$,OPL,$,O2P>
        CALL    OREM,<1>
        J       CNVI11
;                       CNVI 9
CNVI9:  CALL    FND2R,<$,OP>,<OPL>
        CALL    GRNT,<O(FLTR),$,OPL,$,OP>
;                       CNVI 10
        MOVSI   0,(SETZ)
        M       1,OPL
        ADDI    1,1
        DPB     1,ACZ
        CALL    GRI,<,0>
;                       CNVI 11
CNVI11: MI      1,OREG
        M       2,OP
        FPUT    1,2,OM
        SETZ    1,0
        FPUT    1,2,OV
        M       1,OPL
        FPUT    1,2,OL
        SUBI    2,OPDSTK
        LSH     2,-2
        MM      2,RGSV(1)
;                       CNVI 12
        M       3,NT
        CAIN    3,REAL
        J       CNVI14
;                       CNVI 13
        MM      2,RGSV+1(1)
;                       CNVI 14
CNVI14: M       1,OPM
        CAIE    1,OLVAR
        J       CNVI$$
;                       CNVI 15
        CALL    TQFRE,<$,OPV>
CNVI$$: BRETURN CNVI
        SUBTTL CNVD CNVRT.7.3 CONVERT A DOUBLE TO INTEGER,REAL OR COMPLEX
        BDCL    CNVD


;                               CNVD 2
        M       1,NT
        CAIE    1,INT
        J       CNVD4

;                               CNVD 3
        CALL    LD,<$,OP>,<OPL>
        BCALL   CNVDI
        J       CNVD$$

;                               CNVD 4
CNVD4:  CALL    LDR,<1,$,OP>
        CALL    CXR,<.DSING>

;                               CNVD 5
        M       1,NT
        CAIE    1,REAL
        J       CNVD7

;                               CNVD 6
        SETZM   RGSV+2          ;R2 IS NOW FREE
        J       CNVD$$

;                               CNVD 7
CNVD7:  MOVSI   0,(SETZ 2,)
        SETZ    1,0
        CALL    GRI

;                               EXIT CNVD
CNVD$$: BRETURN CNVD
        SUBTTL CNVDI CNVRT.7.3.3  CONVERT FROM DOUBLE TO INTEGER
        BDCL    CNVDI

;                               CNVDI 1
        M       1,OPL
        M       2,RGSV(1)
        MM      2,OPV
        MI      2,ORSVD
        MM      2,RGSV(1)
        MM      2,RGSV+1(1)
        CALL    FNDNZ,,<RGY>
        CALL    SVR,<$,1>

;                               CNVDI 2
        CALL    FIXD,<$,OPL,$,RGY,O(ASHC)>

;                               CNVDI 3
        MOVE    1,OPL
        ADDI    1,1
        M       0,[TLNE 0,^O200000]
        DPB     1,ACZ
        SETZ    1,0
        CALL    GRI
        M       0,[ADDI 0,1]
        M       1,OPL
        DPB     1,ACZ
        SETZ    1,0
        CALL    GRI

;                               CNVDI 4
        M       1,OPL
        SETZM   RGSV+1(1)
        M       2,OPV
        MM      2,RGSV(1)

;                               EXIT CNVDI
        BRETURN CNVDI
        SUBTTL CNVTI CNVRT.7.5 CONVERT REAL OR COMPLEX TO INTEGER
        BDCL    CNVTI

;                               CNVTI 1
        M       1,OPM
        CAIE    1,OREG
        J       CNVTI5

;                               CNVTI 2
        MOVSI   0,(FIXR)
        M       1,OPL
        DPB     1,ACZ
        HRR     0,1
        SETZ    1,0
        CALL    GRI

;                               CNVTI 3
        M       1,OPT
        CAIE    1,CMPLX
        J       CVTI$$

;                               CNVTI 4
        M       1,OPL
        SETZM   RGSV+1(1)
        J       CVTI$$

;                               CNVTI 5
CNVTI5: CALL    FNDR,<1>,<OPL>
        CALL    SVR,<$,1>

;                               CNVTI 6
        CALL    GRNT,<O(FIXR),$,OPL,$,OP>
        M       1,OP
        SUBI    1,OPDSTK
        LSH     1,-2
        M       2,OPL
        MM      1,RGSV(2)
        M       2,OP
        MI      1,OREG
        FPUT    1,2,OM
        M       1,OPL
        FPUT    1,2,OL
        SETZ    1,0
        FPUT    1,2,OV

;                       CNVTI 7
        M       1,OPM
        CAIE    1,OLVAR
        J       CVTI$$

;                       CNVTI 8
        CALL    TQFRE,<$,OPV>

;                               EXIT CNVTI
CVTI$$: BRETURN CNVTI
        SUBTTL CNVC CNVRT.7.9   CONVERT COMPLEX TO REAL OR DOUBLE
        BDCL    CNVC

;                               CNVC 1
        M       1,NT
        CAIE    1,REAL
        J       CNVC4

;                               CNVC 2
        M       1,OPM
        CAIE    1,OREG
        J       CNVC$$

;                               CNVC 3
        M       1,OPL
        SETZM   RGSV+1(1)
        J       CNVC$$

;                               CNVC 4
CNVC4:  CALL    LD,<$,OP>,<OPL>
        M       1,OPL
        ADDI    1,1
        MOVSI   0,(SETZ)
        DPB     1,ACZ
        SETZ    1,0
        CALL    GRI

;                               EXIT CNVC
CNVC$$: BRETURN CNVC
        SUBTTL CNVTL CNVRT.8  CONVERT A NON CONSTANT TO A LOGICAL
        BDCL    CNVTL

        SETZ    1,0
        M       2,OP
        FPUT    1,2,ONG
;                               CNVTL 1
        M       1,OPM
        CAIE    1,OREG
        J       CNVTL3
        M       1,OPT
        CAIG    1,REAL
        J       CNVTL3

;                               CNVTL 2
        M       1,OPL
        SETZM   RGSV+1(1)
        J       CNVTL4

;                               CNVTL 3
CNVTL3: MI      1,INT
        M       2,OP
        FPUT    1,2,OT
        CALL    LD,<$,2>,<OPL>

;                               CNVTL 4
CNVTL4: MOVSI   0,(CAIE)
        M       1,OPL
        DPB     1,ACZ
        SETZ    1,0
        CALL    GRI
        M       0,[MOVEI 0,1]
        M       1,OPL
        DPB     1,ACZ
        SETZ    1,0
        CALL    GRI

;                               EXIT CNVTL
        BRETURN CNVTL
        SUBTTL CNVK CNVRT.9  CONVERT A CONSTANT
        BDCL    CNVK

        JFCL    ^O17,.+1        ; CLEAR ALL FLAGS
;                               CNVK 1
        M       1,NT
        CAIN    1,INT
        J       CNVK4
        CAIE    1,LOG
        J       CNVK6

;                               CNVK 2
        SKIPN   OPV
        J       CNVK13

;                               CNVK 3
        MI      1,1
        M       2,OP
        FPUT    1,2,OV
        J       CNVK13

;                               CNVK 4
CNVK4:  M       1,OPT
        CAIN    1,LOG
        J       CNVK13

;                               CNVK 5
        BCALL   KFIX
        J       CNVK13

;                               CNVK 6
CNVK6:  M       1,OPT
        CAIN    1,REAL
        J       CNVK13

;                               CNVK 7
        M       1,OPV

;                               CNVK 8
        M       2,OPT
        CAIN    2,DBL
        J       CNVK10

;                               CNVK 9
        FLTR    1,1
        J       CNVK12

;                               CNVK 10  and now we convert a double to a real
CNVK10:M 2,OPL

;                               CNVK 11
        JUMPL   R1,DTOS1        ;Negative argument?
        TLNE    R2,^O200000     ;Positive. Is a round required?
        TRON    R1,1            ;Yes, try to round by setting LSB of word 1
        JRST    CNVK12          ;Success, we're done
        MOVE    R2,R1           ;LSB was already on - copy high part of arg
        AND     R1,[^O777000,,1] ;Make an unnormalized LSB with same exponent
        FADR    R1,R2           ;Add it in, round and normalize
        JRST    CNVK12

DTOS1:  DMOVN   R1,R1           ;Negative argument - make positive
        TLNE    R2,^O200000     ;Does it need rounding?
        TRON    R1,1            ;Yes, try to round by setting LSB of word 1
        JRST    DTOS2
        MOVN    R2,R1           ;Make re-negated copy of high-order word
        ORCA    R1,[^O777,,-1]  ;Make an unnormalized negative LSB with same exponent
        FADR    R1,R2           ;Add it in, round and normalize
        SKIPA                   ; and were done
DTOS2:  MOVN    R1,R1           ;Re-negate

;                               CNVK 12
CNVK12: M       3,OP
        FPUT    1,3,OV

;                               CNVK 13
CNVK13: MI      1,0
        M       2,OP
        FPUT    1,2,OL

;                       CNVK 13A
        JOV     CK13B
        J       CNVK14
;                       CNVK 13B
CK13B:  CALL    CERR,<44>
;                               CNVK 14
CNVK14: M       1,NT
        CAIE    1,CMPLX
        J       CNVK$$

;                               CNVK 15
        CALL    FNDR,<2>,<OPL>
        CALL    SVR,<$,1>
        M       0,OPL
        ADDI    0,1
        CALL    SVR
        CALL    LDR,<$,OPL,$,OP>
        M       1,OPL
        M       2,RGSV(1)
        MM      2,RGSV+1(1)

;                               CNVK 16
        M       1,OPL
        ADDI    1,1
        MOVSI   0,(SETZ)
        DPB     1,ACZ
        SETZ    1,0
        CALL    GRI

;                               EXIT CNVK
CNVK$$: BRETURN CNVK
        SUBTTL KFIX CNVRT.9.5 CONVERT A DOUBLE OR REAL CONSATNT TO AN INTEGER
        BDCL    KFIX

;                               KFIX 1
        M       1,OPT
        CAIE    1,DBL
        J       KFIX5

;                               KFIX 2
        M       1,OPV
        M       2,OPL

;                               KFIX 3
        M       3,1
        TLNN    1,^O400000
        TLZA    1,^O377000
        TLO     1,^O377000

;                               KFIX 4
        ASH     3,-27
        TRNE    3,^O400
        SETCA   3,0
        SUBI    3,128+27
        ASHC    1,0(3)
        TLNE    2,^O200000
        ADDI    1,1
        J       KFIX7

;                               KFIX 5
KFIX5:  M       1,OPV

;                               KFIX 6
        FIXR    1,1

;                               KFIX 7
KFIX7:  M       3,OP
        FPUT    1,3,OV

;                               EXIT KFIX
        BRETURN KFIX
        SUBTTL CRIP  PROCESS A READ OR INPUT STATEMENT
        DCL     CRIP,<RN>,<ID>

;                               CRIP 1
        CALL    CKLVA
;                       CRIP 4
        MOVE    0,RN
        CAIE    0,RREAD
        JRST    CRIP5
        CALL    GRI,<$,<[MOVEI 0,MDATPT]>,UVAR>

;                       CRIP 5
CRIP5:  MOVE    1,O2P
        FGET    0,1,OC
        CAIE    0,OMX
        J       CRIP7
;                       CRIP 6
        CALL    CXR,<$,RN>
        J       CRIP11
;                       CRIP 7
CRIP7:  MOVE    0,RN
        CAIE    0,RREAD
        HRLZI   2,^O10740
        CAIN    0,RREAD
        HRLZI   2,^O7740
         
;                       CRIP 9
        CALL    TRCXR,<,$,O2P>
;                       CRIP 11
CRIP11: M       1,O2P
        FGET    2,1,OC
        FGET    0,1,OT
        HRL     0,2
        CALL    GRI,<,0>
        CALL    OREM,<1>
;                               EXIT CRIP
        MOVE    0,RN
        RETURN  CRIP
        SUBTTL CXR   GENERATE A CALL TO A RUNSIDE ROUTINE

;  procedure cxr(rn,mopid)

;  ! Generates a call to a runtime routine rn.  mopid is used only if rn is repwr
;  ! rmsop, reeops, reepwr, or reecmp, in which case mopid is generated as an instruction
;  ! before the routine is called.  Different things are done in setting up
;  ! the call, depending on whether the routine is defined in rlist1,
;  ! rlist2, or rlist3.  See those definitions for more information.

;  local typ, lo, vl, ng  ! Type, location, value, # of dimensions

;  eif rn<=xrtmax then cxtvt()  ! rlist1
;  fif rn<=xramax then cxtva()  ! rlist2
;  cxrrr(rn)

;  end cxr



        dcl     cxr,<RN,MOPID>,<TYP,LO,VL,NG>

        move    0,rn
        caig    0,xrtmax
        jrst    cxtvt           ; returns to cxrz
        caig    0,xramax
        jrst    cxtva           ; returns to cxrz
cxrz:   call    cxrrr,<$,rn>

        return  cxr
        SUBTTL CXTVT  CALL A ROUTINE IN RLIST1

;  block cxtvt (local to cxr)

;  ! Sets up for a call to a routine in rlist1.  rtvf has in the left half the
;  ! result type for each routine, in the right half the number of dimensions.

;  typ := rtvf[rn].lh;  ng := rtvf[rn].rh

;  eif ng#0 then
;    do  ! array result
;    [lo;vl] := tqafnd(.SZDSC[ng])
;         (note: .szdsc is size of a non slice descriptor
;               if slices may be used, then use .wstcs instead)
;    gri([movei 4,lo],lvr)
;    tvf(omx,otmp,typ,lo,vl,ng)
;    end
;  orif typ=str then
;    do  ! string scalar result
;    [lo;vl] := tqsfnd
;    gri([movei 4,lo],lvr)
;    tvf(ossc,otmp,str,lo,vl,ng)
;    end
;  else
;    do  ! numeric scalar result
;    tvr(1,typ)
;    end

;  end cxtvt

        SALL

cxtvt:
        move    2,rn
        hlrz    0,rtvf(2)
        movem   0,typ           ; typ := rtvf[rn].lh
        hrrz    1,rtvf(2)
        movem   1,ng            ; ng := rtvf[rn].rh

        jumpn   1,[call tqafnd,<$,.SZDSC(1)>,<lo,vl> ; eif ng#0 then ...
        move    0,lo
        hrli    0,(movei 4,)
        call    gri,<,lvr>
        call    tvf,<omx,otmp,$,typ,$,lo,$,vl,$,ng>
        jrst    cxft$$  ]

        cain    0,str           ; orif typ=str then ...
        jrst    [  call tqsfnd,<2>,<lo,vl>
        move    0,lo
        hrli    0,(movei 4,)
        call    gri,<,lvr>
        call    tvf,<ossc,otmp,str,$,lo,$,vl,$,ng>
        jrst    cxft$$  ]

        call    tvr,<1,$,typ>   ; else ...

cxft$$: jrst    cxrz
        XALL
        SUBTTL CXTVA  CALL A COMPLICATED ARRAY VALUED ROUTINE

;  block cxtva (local to cxr)

;  ! Sets up for a call to a complicated array-valued routine.  These are listed
;  ! in rlist2, and require all kinds of special stuff.

;  ckc(o2p,omx)

;  eif rn=(reeops or reepwr or reecmp or raact or raint or ramul) then
;    do  ! These guys take two array arguments, give variously dimensioned results
;    ckc(o1p,omx)
;    eif rn=raint then
;      ng := 11   ! see note below explaining why we set it for 11 dimensions
;    orif rn=ramul then
;      do
;      if not (o1p.ong=(1 or 2 or 11) and o2p.ong=(1 or 2 or 11)) then cerr(31)
;      eif o1p.ong=11 or o2p.ong=11 then ng := 11
;      else                              ng := o1p.ong+o2p.ong-2
;      end
;    else
;      do  ! reeops, reepwr, reecmp, raact
;      ng := max(o1p.ong,o2p.ong)
;      cknd(o1p,o2p.ong)
;      end
;    typ := max(o1p.ot,o2p.ot)
;    if ng > 0 then [lo;vl] := tqafnd(.SZDSC[ng])
;    gr2m()
;    end

;  else
;    do  ! The rest take one array argument, give result of same dimensionality
;    if rn=(rminv or rmtrn or rmpwr) then cknd(o2p,2)
;    ng := o2p.ong;  typ := o2p.ot
;    [lo;vl] := tqafnd(.SZDSC[ng])
;    gr1m()
;    end

;  if rn=(repwr or rmsop or reeops or reepwr or reecmp) then gri(mopid,0)
;  gri([movei 4,lo],lvr)
;  eif ng=0 then
;   tvr(1,typ)
;  else
;   tvf(omx,otmp,typ,lo,vl,ng)

;  end cxtva

; ng=11 means we put 11 int the  number of dimensions field of the operand
; because we can not determine at compil time the number of dimensions the
; array will have. The primary cause of this is array intersection. recall
; that the intesection of two arrays is the set of elements the arrays have in
; common. The two arrays then must have a common parent. The intersection of
; two 3-dimensional arrays may be null or an array of 1,2, or 3 dimensions.
; The dimensionality of an array intersection is thus indeterminit at
; compil time. Other array operators may also give a result of indeterminit
; dimensionality if given an operand of indeterminit dimensionality.

        SALL

cxtva:
        call    ckc,<$,o2p,omx>

        move    0,rn            ; if rn=(reeops or reepwr or reecmp or raact or raint or ramul) then
        caie    0,reeops
        cain    0,raact
        jrst    cxfa1
        caie    0,raint
        cain    0,ramul
        jrst    cxfa1
        caie    0,reepwr
        cain    0,reecmp
        jrst    cxfa1
        jrst    cxfa2

cxfa1:  call    ckc,<$,o1p,omx>

        move    0,rn
        cain    0,raint         ; eif rn=raint then
        jrst    [  movei 0,11
        movem   0,ng            ; ng := 11
        jrst    cxfa3  ]

        caie    0,ramul         ; orif rn=ramul then
        jrst    cxfa4

        move    1,o1p           ; if not (o1p.ong=(1 or 2 or 11) and o2p.ong=...
cxfa5:  fget    0,1,ong
        caie    0,1             ; These tests are performed for both o1p and o2p
        cain    0,2
        jrst    cxfa5a
        caie    0,11
        jrst    [  call(cerr,<31>)]
cxfa5a: came    1,o2p
        jrst    [  move 1,o2p   ; did o1p, now check o2p
        jrst    cxfa5  ]

        move    3,o1p
        fget    1,3,ong
        move    3,o2p
        fget    2,3,ong
        move    0,1             ; r0 := o1p.ong+o2p.ong-2
        addi    0,-2(2)         ; this add may give garbage in the lh (note hrrzm below)
        caie    1,11
        cain    2,11
        movei   0,11            ; if o1p.ong=11 or o2p.ong=11 then r0 := 11
        hrrzm   0,ng            ; ng := whatever

        jrst    cxfa3

cxfa4:  move    3,o1p
        fget    1,3,ong
        move    3,o2p
        fget    2,3,ong
        camge   1,2
        move    1,2             ; ng := max(o1p.ong,o2p.ong)
        movem   1,ng

        move    1,o2p
        fget    1,1,ong
        call    cknd,<$,o1p,>

cxfa3:  move    3,o1p
        fget    1,3,ot
        move    3,o2p
        fget    2,3,ot
        camge   1,2
        move    1,2             ; typ := max(o1p.ot,o2p.ot)
        movem   1,typ

        move    1,ng
        jumpe   1,cxfa2a
        call    tqafnd,<$,.SZDSC(1)>,<lo,vl>

cxfa2a: call    gr2m

        jrst    cxfa6

cxfa2:  move    0,rn
        caie    0,rminv
        cain    0,rmtrn         ; if rn=(rminv or rmtrn or rmpwr) then
        skipa
        cain    0,rmpwr
        jrst    [  call cknd,<$,o2p,2>
        jrst    .+1  ]

        move    3,o2p
        fget    1,3,ong
        movem   1,ng            ; ng := r1 := o2p.ong  (r1 is used below)
        fget    2,3,ot
        movem   2,typ           ; typ := o2p.ot

        call    tqafnd,<$,.szdsc(1)>,<lo,vl>

        call    gr1m

cxfa6:  move    0,rn
        caie    0,repwr         ; if rn=(repwr or rmsop or reeops or reepwr or reecmp) then
        cain    0,rmsop
        jrst    cxfa6a
        caie    reeops
        cain    reepwr
        jrst    cxfa6a
        caie    reecmp
        jrst    cxfa6b
cxfa6a: call    gri,<$,mopid,0>

cxfa6b: skipn   ,ng
        jrst    cxfa7
        move    0,lo
        hrli    0,(movei 4,)
        call    gri,<,lvr>

        call    tvf,<omx,otmp,$,typ,$,lo,$,vl,$,ng>

        jrst    cxrz

cxfa7:  call    tvr,<1,$,typ>
        jrst    cxrz
        XALL
        SUBTTL CXRR     PRINT SOME STUFF IF WE ARE DOING A CDE
        DCL     CXRR,<RN>

;                               CXRR 1
        SKIPG   CDEFLG
        J       CXRR$$

;                               CXRR 2
        CALL    CXTDO,<32>
        CALL    CXTDO,<32>
        M       1,RN
        HRRZ    0,XTBH(1)
        CALL    TDO,<,MONOCR>

;                               EXIT CXRR
CXRR$$: RETURN  CXRR
        SUBTTL CXRRR
        DCL     CXRRR,<RN>
;                       CXRRR 1
        M       3,RN
        M       1,XTBL(3)
        M       2,r%cdlc
        MM      2,XTBL(3)
        MOVSI   0,(PUSHJ RXP,)
        CALL    GRJ

;                               CXRRR 2
        CALL    CXRR,<$,RN>

;                       EXIT CXRRR
        RETURN  CXRRR
        SUBTTL CZLD  LOAD THE MOST CONVIENENT OF THE TWO OPERANDS
        DCL     CZLD,<OP1,OP2>

;                               CZLD 1
        M       2,OP1
        FGET    1,2,OM
        CAIN    1,OREG
        J       CZLD$$

;                               CZLD 2
        M       2,OP2
        FGET    1,2,OM
        CAIE    1,OREG
        J       CZLD4

;                               CZLD 3
        M       1,OP2
        EXCH    1,OP1
        MM      1,OP2
        J       CZLD$$

;                               CZLD 4
CZLD4:  M       2,OP1
        FGET    1,2,OM
        CAIE    1,OKON
        J       CZLD6

;                               CZLD 5
        M       1,OP2
        EXCH    1,OP1
        MM      1,OP2

;                               CZLD 6
CZLD6:  CALL    LD,<$,OP1>

;                               EXIT CZLD
CZLD$$: M       4,OP1
        FGET    3,4,OL
        RETURN  CZLD,<$,OP1,$,OP2>
        SUBTTL DPLIT   DEPOSIT LITERALS
        DCL     DPLIT,,<LNG,N,VP,LITP,REM,DPLFLG>


;                               DPLIT 1
        SKIPN   PIFXP
        J       DPLIT2
;                       DPLIT 1B
        SKIPG   CDEFLG
        JRST    DPLT1B
        MOVEI   0,[ASCIZ / PI AND DPI/]
        CALL    TDO,<,1>

DPLT1B: CALL    CHFXP,<$,PIFXP>
        CALL    GRI,<$,PI,0>
        CALL    GRI,<$,PILO,0>

;                               DPLIT 2
DPLIT2: CALL    TSET,<$,LIT,1>
        CALL    VSTART,<$,SLIT>
        SETOM   DPLFLG

;                               DPLIT 3
DPLIT3: CALL    TNEXT,<$,LIT>,<LITP>

;                               DPLIT 4
        SKIPN   LITP
        J       DPLT15
        SKIPE   ESCFLG
        J       DPLT15

        SKIPLE  CDEFLG
        SKIPN   DPLFLG
        JRST    DPLIT5
        CALL    CXTDO,<10>
        MOVEI   0,[ASCIZ / LITERALS/]
        CALL    TDO,<,1>
        SETZM   DPLFLG

;                               DPLIT 5
DPLIT5: SKIPG   CDEFLG
        JRST    DPLT5A
        CALL    CXTDO,<10>

DPLT5A: MOVE    1,LITP
        FGET    0,1,LADR
        CALL    CHFXP

;                               DPLIT 6
        M       2,LITP
        FGET    1,2,LTYP
        CAIN    1,6
        J       DPL14A
        CAIN    1,STR
        J       DPLIT8
        CAIN    1,CMPLX
        J       DPLIT7
        CAIE    1,DBL
        J       DPLT14

;                               DPLIT 7
DPLIT7: M       1,LITP
        FGET    0,1,LV
        CALL    GRI,<,0>
        M       1,LITP
        FGET    0,1,LL
        CALL    GRI,<,0>
        J       DPL15A

;                               DPLIT 8
DPLIT8: CALL    VNEXT,<MBUFD,$,SLIT>,<VP>
        MI      2,MBUFD
        FGET    1,2,SDCL
        MM      1,LNG
        SETZM   N

;                               DPLIT 9
        SKIPN   VP
        J       DPLT13

;                               DPLIT 9 A
        SKIPG   CDEFLG
        JRST    DPLT10

        MOVEI   0,[ASCIZ /  STRING: /]
        CALL    TDO,<,1>
        MOVE    1,LNG           ; IM MAKING SURE THE STRING HAS A TRAILING NULL
        IDIVI   1,5
        MOVE    0,MSKTBL(2)
        ANDM    0,MBUF(1)
        MOVEI   0,MBUF
        CALL    TDO,<,2>

;                               DPLIT 10
DPLT10: MOVE    0,r%cdlc
        ADDI    0,2
        CALL    GRI,<,LOC>
        M       0,LNG
        LSH     0,18
        ADD     0,LNG
        CALL    GRI,<,0>
        M       1,LNG
        ADDI    1,4
        IDIVI   1,5
        MM      1,LNG
        MM      2,REM

;                               DPLIT 11
DPLT11: M       1,N
        CAML    1,LNG
        J       DPL12A
;                       DPLIT 12
        M       0,MBUF(1)
        TRZ     0,1
        CALL    GRI,<,0>
        AOS     N
        J       DPLT11

;                               DPLIT 12A
DPL12A: M       1,REM
        CAIE    1,4
        J       DPL15A
;                       DPLIT 12B
        CALL    GRI,<0,0>
        J       DPL15A


;                               DPLIT 13
DPLT13: CALL    CXR2,<$,CMSG+10,MOCR>
        J       DPL15A

;                       DPLIT 14A
DPL14A: M       1,LITP
        FGET    0,1,LV
        CALL    GRI,<,LVR>
        J       DPL15A
;                               DPLIT 14
DPLT14: M       1,LITP
        FGET    0,1,LV
        CALL    GRI,<,0>

;                       DPLIT 15A
DPL15A: MOVE    R1,LITP
        CALL    RCLN
        J       DPLIT3

;                               DPLIT 15
DPLT15: SKIPN   LITP
        J       DPLT17

;                               DPLIT 16
        M       1,LITP
        CALL    RCLN
        MI      1,1
        J       DPLT$$

;                               DPLIT 17
DPLT17: MI      1,0

;                               EXIT DPLIT
DPLT$$: RETURN  DPLIT
        SUBTTL EXCK  MAKE SURE YOU ARE RETURNING FROM THE CORRECT SUBROUTINE
        DCL     EXCK,,<PROP,SDTP>

;                               EXCK 1
        M       1,SUBNM
        JN      1,EXCK3

;                               EXCK 2
        CALL    CERR,<LVNP7>

;                               EXCK 3
EXCK3:  CALL    TTLOG
        CALL    TLOC,<$,PRODT,$,SUBNM>,<PROP>
        FGET    1,1,PNAM
        CALL    SDTGET,,<SDTP>

;                               EXCK 4
        FGET    0,1,SKND
        CAIN    0,SPRO
        J       EXCK$$

;                               EXCK 5
        CALL    IMPOS

;                               EXIT EXCK
EXCK$$: RETURN  EXCK,<$,SDTP,$,PROP>
        SUBTTL EXDR  DEALLOCATE STRINGS AND ARRAYS, RETURN TO LOCATION OF CALL
        DCL     EXDR,<SDP,PROP>,<WW,PDTP,SDTP>

;                               EXDR 1
        M       1,RTFG
        JE      1,EXDR3

;                               EXDR 2
        M       1,PROP
        CALL    RCLN
        CALL    JMP,<$,RTAD>
        J       EXDR$$

;                               EXDR 3
EXDR3:  M       1,r%cdlc
        MM      1,RTAD
        MOVE    R2,PROP
        FGET    R0,R2,PNP
        MOVEM   R0,WW           ;number of paramters
        FGET    R1,R2,PPARS     ;pointer to first PARDT record for this procedure
        EXCH    R1,R2
        CALL    RCLN
        MOVE    R1,R2
        SKIPG   WW
        JRST    EXDR15
        CALL    TSET,<$,PARDT>

;                               EXDR 4
        M       1,WW
        JLE     1,EXDR15

;                               EXDR 5
EXDR5:  CALL    TNEXT,<$,PARDT>,<PDTP>
        FGET    1,1,PANAM
        CALL    SDTGET,,<SDTP>

;                               EXDR 6
        MOVE    2,1
        FGET    1,2,SKND
        CAIN    1,SPARY
        J       EXDR9
        CAIE    1,SSCAL
        J       EXDR10

;                               EXDR 7
        FGET    1,2,STYP        ; SDTP IN R2, BOX 6
        CAIE    1,STR
        J       EXDR12

;                               EXDR 8
        SETOM   RTFG
        CALL    SAVREG
        M       2,SDTP
        FGET    0,2,SLOC
        HRLI    0,(MOVEI 2,)
        CALL    GRI,<,UVAR>
        CALL    CXR,<RXPSS>
        J       EXDR12

;                               EXDR 9
EXDR9:  SETOM   RTFG
        CALL    SAVREG
        M       2,SDTP
        FGET    0,2,SLOC
        HRLI    0,(MOVEI 2,)
        CALL    GRI,<,UVAR>
        CALL    CXR,<RXPMX>
        J       EXDR12

;                               EXDR 10
EXDR10: MOVE    1,PDTP
        CALL    RCLN

;                               EXDR 11
        CALL    IMPOS

;                               EXDR 12
EXDR12: MOVE    R1,PDTP
        CALL    RCLN
        SOS     1,WW

;                               EXDR 13
        M       1,WW
        JG      1,EXDR5

;                               EXDR 15
EXDR15:M 2,SDP
        FGET    0,2,SLOC
        ADDI    0,1
        HRLI    0,(MOVE RXO,)
        CALL    GRI,<,UVAR>
        M       2,SDP
        FGET    0,2,SLOC
        HRLI    0,(JRST @)
        CALL    GRI,<,UVAR>

;                               EXIT EXDR
EXDR$$: RETURN  EXDR
        SUBTTL EZLD     LOAD THE MOST CONVIENENT OF THE TWO OPERANDS
        DCL     EZLD

;                               EZLD 1
        CALL    CZLD,<$,O1P,$,O2P>

;                               EXIT EZLD
        RETURN  EZLD
        SUBTTL FFFXP
        DCL     FFFXP
;                       FFFXP 1
        CALL    TLOC,<$,FORSTK,0>,<FORP>
        M       2,FORP
        FGET    1,2,FFXP
;                       FFFXP 2
        FGET    3,2,FFLG
        JUMPG   3,FFFX4
;                       FFFXP 3
        M       4,r%cdlc
        FPUT    4,2,FFXP
;                       FFFXP 4
FFFX4:  MOVSI   0,(JSP RXJ,)
        CALL    GRJ
        MOVE    R1,FORP
        CALL    RDTY
;                       EXIT FFFXP
        RETURN  FFFXP
        SUBTTL FIXD  FIX A DOUBLE PRECISION NUMBER. DO NOT ROUND
        DCL     FIXD,<OPL,RGY,WW>

;                               FIXD 1
        MOVSI   0,(MOVE)
        DPB     1,ACZ
        HRR     0,OPL
        SETZ    1,0
        CALL    GRI
        M       0,[TLNN 0,^O400000]
        M       1,OPL
        DPB     1,ACZ
        SETZ    1,0
        CALL    GRI
        M       0,[TLZA 0,^O377000]
        M       1,OPL
        DPB     1,ACZ
        SETZ    1,0
        CALL    GRI
        M       0,[TLO 0,^O377000]
        M       1,OPL
        DPB     1,ACZ
        SETZ    1,0
        CALL    GRI

;                               FIXD 2
        M       0,[ASH 0,-27]
        M       1,RGY
        DPB     1,ACZ
        SETZ    1,0
        CALL    GRI
        M       0,[TRNE 0,^O400]
        M       1,RGY
        DPB     1,ACZ
        SETZ    1,0
        CALL    GRI
        MOVSI   0,(SETCA)
        M       1,RGY
        DPB     1,ACZ
        SETZ    1,0
        CALL    GRI
        M       0,[SUBI 0,128+27]
        M       1,RGY
        DPB     1,ACZ
        SETZ    1,0
        CALL    GRI
        MI      0,0
        M       1,OPL
        DPB     1,ACZ
        M       1,RGY
        DPB     1,XRZ
        M       1,WW
        DPB     1,OPCDZ
        SETZ    1,0
        CALL    GRI

;                               EXIT FIXD
        RETURN  FIXD
        SUBTTL FND2R  FIND AND SAVE TWO REGISTERS FOR THE OP
        DCL     FND2R,<OP>,<RGX>

;                               FND2R 1
        M       2,OP
        FGET    1,2,OM
        CAIE    1,OREG
        J       FND2R6

;                               FND2R 2
        FGET    1,2,OL          ; OP USED FROM BOX 1,R2
        MM      1,RGX

;                               FND2R 3
        CAIE    1,10
        J       FND2R5

;                               FND2R 4
        SETZM   0,RGSV+10
        MI      1,9
        MM      1,RGX
        CALL    SVR,<9>
        J       FD2R$$

;                               FND2R 5
FND2R5: M       0,RGX
        ADDI    0,1
        CALL    SVR
        J       FD2R$$

;                               FND2R 6
FND2R6: CALL    FNDR,<2>,<RGX>
        CALL    SVR,<$,1>
        M       0,RGX
        ADDI    0,1
        CALL    SVR

;                               EXIT FND2R
FD2R$$: RETURN  FND2R,<$,RGX>
        SUBTTL FNDR  FIND THE MOST AVAILABLE REGISTER OR REGISTER PAIR

; This is a popular routine. it showed up in the profils.
; I think what were doing is lokking at each register and judging its availability
; by the operand that its currently holding. the symbols used are:
;   N - number of registers needed (1 or 2)
;   R - most available register
;   RN - current register
;   RS - status of register R
;   RNS - status of register RN

; The status of register r is RGSV[r] where:
;   RGSV[r] = 0  means the register is unused
;   RGSV[r] = n  means the register is being used by operand OPDL[n]
;   RGSV[r] = ORSVD# means that for some reason compil says no
;      ORSVD# is positive so the lower the status, the more avaliable the reg

        DCL     FNDR,<N>,<R,RN,RS,RNS>
        MOVE    1,N
        CAILE   1,2
        HALT                    ; make sure no more than 2 registers requested

;                               FNDR 1  initialize register and status
        MOVEI   1,^O11  ; start looking at register 11 OCTAL
        MOVEM   1,RN
        SETOM   R       ; r := -1 to signify no register found
        MI      1,ORSVD ; status of register r is unusable
        MM      1,RS

;                               FNDR 2  get status of register rn
FNDR2:  M       1,RN
        M       2,RGSV(1)
        MM      2,RNS

;                               FNDR 3  dont use a reg containing O2P
        CAML    2,OPDN
        J       FNDR10

;                               FNDR 4  maybe look at the next register
        MOVE    1,N     ; are we looking for a pair of register?
        CAIG    1,1
        JRST    FNDR8   ; if not, dont bother looking
        MOVE    1,RN    ; if the second register has the same status as the first
        MOVE    2,RGSV+1(1)     ; then dont bother looking, it wont matter
        CAMN    2,RNS
        J       FNDR8

;                               FNDR 5  dont use a reg containing O2P
        M       2,RGSV+1(1)     ; RN IN R1, BOX 4
        CAMGE   2,OPDN
        J       FNDR7

;                               FNDR 6  it uses O2P so we say no
        MI      1,ORSVD
        ADDM    1,RNS
        J       FNDR8

;                               FNDR 7  this register pair is used by two ops
FNDR7:  M       1,RN
        M       2,RGSV+1(1)
        ADDM    2,RNS   ; the status is the sum of the operand numbers

;                               FNDR 8  is the status an all time low?
FNDR8:  MOVE    2,RNS
        MOVE    1,RN
        JUMPE   2,FNDR$$        ; HOUHA SAYS USE TEH FIRST FREE REGISTER WE SEE
        CAMLE   2,RS
        J       FNDR10

;                               FNDR 9  yes, make this the most available yet
        MOVEM   2,RS
        MM      1,R

;                               FNDR 10  we stop after register 0
FNDR10: SKIPGE   RN
        JRST    FNDR12

;                               FNDR 11  next register
        SOS     RN
        J       FNDR2

;                               FNDR 12  if no register found
FNDR12: M       1,R
        CAIE    1,-1
        J       FNDR$$

;                               FNDR 13  then say impossible
        CALL    IMPOS

;                               EXIT FNDR  else return R, the best we found
FNDR$$: RETURN  FNDR
        SUBTTL FORN  COMPIL CODE FOR A FOR LOOP WITH AN INCREMENT AND A BOUND
        DCL     FORN,<LVAR>,<RGX,LOOP,OP,RGY,LITP,FIXUP,FLVRR,WW>

;                               FORN 1
        CALL    TLOC,<$,FORSTK,0>,<FORP>
        M       2,FORP
        FGET    1,2,FTYP
        MM      1,FORTYP
        CALL    CNVRT,<$,O2P>
        M       2,FORP
        FGET    1,2,FTYP
        CALL    CNVRT,<$,O1P>
        M       1,OPDN
        M       2,OPDL-2(1)
        MM      2,OP
        M       2,FORP
        FGET    1,2,FTYP
        CALL    CNVRT,<$,OP>

;                               FORN 2
        CALL    SVFR,<$,O2P>
        CALL    SVFR,<$,O1P>
        CALL    LD,<$,OP>,<RGX>
        CALL    FNDR,<1>,<RGY>
        M       2,OPDN
        M       1,OPDL-3(2)
        CALL    STO,<$,OP>
        M       1,OPDN
        SUBI    1,1
        CALL    ONUL,<1>
        SETO    1,0
;                       FORN 3
        SKIPE   DEBGSW
        TLZ     1,^O770000
        MM      1,WW

;                               FORN 5
FORN5:  BCALL   FORNC

;                               FORN 6
        M       3,FORP
        FGET    0,3,FLVAR
        M       1,RGX
        DPB     1,ACZ
        MI      1,UVAR
        FGET    2,3,FTYP
        CAIN    2,DBL
        J       FORN8

;               FORN 7
        IOR     0,[MOVEM 0,0]
        J       FORN8B

;               FORN 8
FORN8:  IOR     0,[DMOVEM 0,0]
;                       FORN 8B
FORN8B: AND     0,WW
        CALL    GRI
        SKIPN   DEBGSW
        J       FORN9
;                       FORN 8C
        M       3,FORP
        FGET    1,3,FTYP
        FGET    0,3,FVAR
        HRL     0,1
        CALL    GRI,<,0>
;                               FORN 9
FORN9:  M       2,FORP
        FGET    1,2,FFXP
        FGET    3,2,FFLG
        JUMPG   3,FFFXX
        M       4,r%cdlc
        FPUT    4,2,FFXP
FFFXX:  MOVSI   0,(JSP RXJ,)
        CALL    GRJ
        M       2,OPDN
        M       3,OPDL-2(2)
        MM      3,OP
        CALL    LDR,<$,RGX,$,O2P>

;                               FORN 10
        M       2,FORP
        FGET    1,2,FTYP
        CAIG    1,DBL
        J       FORN16

;                               FORN 15
        CALL    IMPOS

;                               FORN 16
FORN16: CALL    GRG,<QADD,$,RGX,$,OP>
        CALL    OREM,<2>

;                               FORN 17
        CALL    JMP,<$,LOOP>
        CALL    CHFXP,<$,FIXUP>
        MOVE    R1,FORP
        CALL    RDTY

;                               EXIT FORN
        RETURN  FORN
        SUBTTL FORNC  COMPIL CODE TO COMPARE THE ITERATION VARIABLE TO THE BOUND
        BDCL    FORNC
;                       FORNC 1
        M       2,O2P
        FGET    1,2,OM
        CAIE    1,OKON
        J       FORNC6
;                       FORNC2
        FGET    1,2,OV
        JUMPL   1,FORNC4
;                       FORNC 3
        MI      2,OGT
        J       FORNC5
;                       FORNC 4
FORNC4: MI      2,OLT
;                       FORNC 5
FORNC5: M       1,r%cdlc
        MM      1,LOOP
        CALL    CMP,<$,RGX,$,O1P>
        J       FRN13
;                       FORNC 6
FORNC6: CALL    GRNT,<O(MOVEI),$,RGY,$,O1P>
        M       0,RGX
        LSH     0,5
        IOR     0,[HRLI 0,(CAMLE)]
        M       1,RGY
        DPB     1,ACZ
        CALL    GRI,<,0>
;                       FORNC 7
        M       2,O2P
        FGET    0,2,OL
        HRLI    0,(SKIPGE)
        CALL    GRI,<,LVR>
        M       0,RGX
        LSH     0,5
        M       1,RGY
        DPB     1,ACZ
        IOR     0,[HRLI 0,^O315000]
        SETZ    1,0
        CALL    GRI
        M       0,r%vrlc
        M       1,RGY
        DPB     1,ACZ
        IOR     0,[MOVEM 0,0]
        CALL    GRI,<,LVR>
        M       1,r%vrlc
        MM      1,FLVRR
        AOS     r%vrlc
;                       FORNC 8
        M       1,FORTYP
        CAIE    1,DBL
        J       FRNC10
;                       FORNC 9
        M       0,[^O40000001]
        CALL    TVKI
        CALL    GRNT,<O(ADD),$,RGY,$,O2P>
        MOVSI   0,(MOVEM)
        M       1,RGY
        DPB     1,ACZ
        HRR     0,r%vrlc
        CALL    GRI,<,LVR>
        AOS     r%vrlc
        CALL    OREM,<1>
;                       FORNC 10
FRNC10: M       1,r%cdlc
        MM      1,LOOP
        MOVSI   0,(XCT)
        HRR     0,FLVRR
        CALL    GRI,<,LVR>
;                       FORNC 11
        M       1,FORTYP
        CAIE    1,DBL
        J       FRN13
;                       FORNC 12
        M       0,r%cdlc
        ADDI    0,4
        CALL    JMP
        CALL    GRNT,<O(CAME),$,RGX,$,O1P>
        M       0,r%cdlc
        ADDI    0,3
        CALL    JMP
        MOVSI   0,(XCT)
        HRR     0,FLVRR
        ADDI    0,1
        CALL    GRI,<,LVR>
;                       FORNC 13
FRN13:  M       1,r%cdlc
        MM      1,FIXUP
        MOVSI   0,(JRST)
        CALL    GRI,<,0>
;                       EXIT FORNC
        BRETURN FORNC
        SUBTTL FNDNZ FIND A NON ZERO REGISTER (THAT IS DONT FIND ME AC0, I DONT WANT IT)
        DCL     FNDNZ,,<WW>
;                               FNDNZ 1
        M       1,RGSV
        MM      1,WW
        MI      2,ORSVD
        MM      2,RGSV
        CALL    FNDR,<1>
        M       2,WW
        MM      2,RGSV
;                       EXIT FNDNZ
        RETURN  FNDNZ
        SUBTTL GAEL  GET AN ARRAY ELEMENT  (BE SURE TO CALL XAEL FIRST)
        DCL     GAEL,<OP>,<OPC>

;                               GAEL 1
        M       2,OP
        FGET    1,2,OT
        CAIN    1,STR
        J       GAEL$$
        FGET    1,2,OC
        CAIN    1,OMX
        J       GAEL$$

;                               GAEL 2
        FGET    1,2,OL
        CAIN    1,2
        J       GAEL4

;                               GAEL 3
        CALL    IMPOS

;                               GAEL 4
GAEL4:  FGET    1,2,OT
        CAILE   1,REAL
        J       GAEL6

;                               GAEL 5
        MOVEI   1,O(MOVE)
        MM      1,OPC
        J       GAEL7

;                               GAEL 6
GAEL6:  MI      1,O(DMOVE)
        MM      1,OPC
        M       1,OP
        SUBI    1,OPDSTK
        LSH     1,-2
        MM      1,RGSV+3

;                               GAEL 7
GAEL7:  CALL    GR,<$,OPC,2,0,2,0,0>
        MI      1,OREG
        M       2,OP
        FPUT    1,2,OM

;                               EXIT GAEL
GAEL$$: RETURN  GAEL
        SUBTTL GLST     COMPILE AN ON-GOTO OR ON-GOSUB
        DCL     GLST,<N>,<RN,NL,LN,LNUMP,RGX>

        SALL

;                               GLST 1
        BCALL   GLSTR

;                               GLST 2
        SOSL    RN              ; while (dec rn)>=0 then cgoto(0)
        JRST    [  CALL CGOTO,<0>
        JRST    .-1  ]

;                               GLST 3
        M       0,r%cdlc
        SUB     0,NL
        SUBI    0,1
        M       1,RGX
        DPB     1,XRZ
        MI      1,LOC
        SKIPE   N
        J       GLST5
;                       GLST 4
        IOR     0,[J 0,@0]
        CALL    GRI
        J       GLST$$
;                       GLST 5
GLST5:  IOR     0,[M 2,0]
        CALL    GRI

;                               GLST 6
        MI      1,RGOSUB
        M       1,XTBL(1)
        MOVSI   0,(JSP RXJ,)
        CALL    GRJ
        M       1,r%cdlc
        SUBI    1,1
        MI      2,RGOSUB
        MM      1,XTBL(2)

;                               EXIT GLST
GLST$$: RETURN  GLST
        XALL
        SUBTTL GLSTR GLST.1 MAKE SURE THE VALUE OF THE EXPRESSION IS WITHIN THE RANGE
        BDCL    GLSTR

        SALL

;                               GLSTR 1
        ILDB    1,PMCP
        MM      1,RN
        MM      1,NL
        SOS     PMCK
        CALL    CNVRT,<$,O2P,INT>
        CALL    LD,<$,O2P>,<RGX>
        CALL    OREM,<1>
;                               GLSTR 2
; if value in R0, move to R1 to allow indexing
        SKIPN   RGX
        JRST    [  MOVSI 0,(MOVE 1,0)
        MOVEI   1,0
        CALL    GRI
        AOS     RGX             ; RGX := 1
        JRST    .+1  ]

        MOVSI   0,(CAIG)
        M       1,RGX
        DPB     1,ACZ
        HRR     0,RN
        CALL    GRI,<,0>
        M       0,[JUMPG 0,2]
        M       1,RGX
        DPB     1,ACZ
        ADD     0,r%cdlc
        ADD     0,RN
        CALL    GRI,<,WLOC>
        M       0,[ERROR 0,PATMSG+1]
        CALL    GRI,<,0>

;                       EXIT GLSTR
        BRETURN GLSTR
        XALL
        SUBTTL GR       GENERATE THE SPECIFIED INSTRUCTION
        DCL     GR,<INS,ACC,NDR,XRG,ADRS,SEG>,<INSS>

;                               GR 1
        MI      2,INSS
        M       1,INS
        FPUT    1,2,OPCD
        M       1,ACC
        FPUT    1,2,AC
        M       1,NDR
        FPUT    1,2,IND
        M       1,XRG
        FPUT    1,2,XR
        M       1,ADRS
        FPUT    1,2,AD
        CALL    GRI,<$,INSS,$,SEG>

;                               EXIT GR
        RETURN  GR
        SUBTTL GRSH  GENERATE THE SPECIFIED INSTRUCTION  SHORT FORM

; GRSH WAS CONCIEVED BECAUSE I NOTICED THAT OF THE 50 OR SO PEOPLE WHO
; CALL GR, ONLY ABOUT 5 USE THE INDIRECT BIT OR THE INDEX REG.
; ALSO MOST EVERYONE HAD SEG=ABS

;  GRSH GENERATES AN INSTRUCTION IN THE FORM  INS  ACC,ADRS  WITH SEG=ABS

        DCL     GRSH,<INS,ACF,ADRS>,<TINS>

        SETZM   TINS
        MOVEI   2,TINS
        MOVE    1,INS
        FPUT    1,2,OPCD
        MOVE    1,ACF
        FPUT    1,2,AC
        MOVE    1,ADRS
        FPUT    1,2,AD
        CALL    GRI,<$,TINS,0>

        RETURN  GRSH

        SUBTTL GRG      GENERATE AN INSTRUCTION FOR AN ARITHMETIC OPERATION
        DCL     GRG,<INS,RGX,OP>


;   INS CODE     ADD=0   SUB=4   MUL=8   DIV=12

;                               GRG 1
        FGET    1,2,OT
        CAIN    1,CMPLX         ;IS TYPE OF OP COMPLEX?
        J       GRG12

;                               GRG 2
        ADD     1,INS           ;ADD TYPE CODE TO INSTRUCTION CODE
        M       1,Q(1)          ;USE SUM TO FIND OPCODE IN TABLE
        MM      1,INS

;                               GRG 3
;               TEST TO SEE IF AN IMMEDIATE OPERAND CAN BE USED
        CALL    TIM,<$,OP>
        JG      1,GRG6
        JUMPE   1,GRG5
;                               GRG 4   CANT USE IMMEDIATE
        CALL    GRNT,<$,INS,$,RGX,$,OP>
        J       GRG$$

;                               GRG 5   USE IMMEDIATE  LEFT HALFWORD=0
GRG5:   M       1,OP
        FGET    0,1,OV
        M       1,INS
        ADDI    1,1
        DPB     1,OPCDZ
        M       1,RGX
        DPB     1,ACZ
        SETZ    1,0
        CALL    GRI
        J       GRG$$
;                       GRG 6  USE IMMEDIATE  RIGHT HALFWORD=0
GRG6:   M       1,OP
        FGET    2,1,OV
        HLRZ    0,2
        M       1,INS
        ADDI    1,1
        DPB     1,OPCDZ
        M       1,RGX
        DPB     1,ACZ
        SETZ    1,0
        CALL    GRI
        J       GRG$$

;                               GRG 12   COMPLEX OP
GRG12:  M       3,0
        M       0,Q+2(3)
        MM      0,INS
        CALL    GRNT,<,$,RGX>
        M       1,RGX
        ADDI    1,1
        CALL    GRNT2,<$,INS,,$,OP>

;                               EXIT GRG
GRG$$:  RETURN  GRG

Q:      EXP     O(ADD),O(ADD),O(FADR),O(DFAD),O(SUB),O(SUB)
        EXP     O(FSBR),O(DFSB),O(IMUL),O(IMUL),O(FMPR),O(DFMP)
        EXP     O(IDIV),O(IDIV),O(FDVR),O(DFDV)
        SUBTTL GRI  GENERATE AN INSTRUCTION

; This is where we actually generate the code. All those other routines
; that say they generate code end up calling GRI with the complete instruction
; in ac0 and the seg # in ac1.
;
; The seg #s :
;       0 - ABS   absolute   like addi 1,1
;       1 - LVR    loseg     like  move 1,24  where 24 is a rxlvar offset
;                LVR is to be used for things that are within the context of
;                the current statement. TEMP CELLs for instance.
;       2 - LOC    hiseg    like  jrst 160l
;                LOC is to be used for things that are within the context of
;                the current statement. like a jrst within a IF or FOR stmt.
;       3 - UVAR   first few words of the loseg which are used for special cases
;                    like pi,startpoint,eps,asctable ...
;                 Also for any User Variables, any thing in the loseg beyond the
;                 context of the current statement.
;       4 - WLOC    workspace location
;                somthing in the hiseg beyond the context of the current statement.

; For UVAR and WLOC we check to see if were in a direct statement
; and if we are we index off of r14 or r15. For LVR and LOC we are within the
; context of the current statement.

; If CDEFLG is set we print the code for a CDE statement.

        DCL     GRI,,<INS,SEG>

;                               GRI 1
        J       @G1TBL(1)
G1TBL:  EXP     GRI16,GRI1A,GRI16,GRI2,GRI8
;                       GRI 1A
GRI1A:  SKIPN   DSFLG
        J       GRI16
;                       GRI 1B
        ADDI    0,DIRLVR-STRTUV ;DIRECT STATEMENT LOSEG AREA,ADJUSTED FOR UNUSED 
                                ;AREA   CAUSED BY PI,EPS, ETC
        SETZ    1,0
        J       GRI16
;                       GRI 2
GRI2:   HRRZ    2,0
        CAILE   2,LOS
        CAIL    2,STRTUV
        JRST    GRI8

; WHEN YOU HAVE AN INSTRUCTION THAT REFERENCES THESE REALLY LOW ADRESSES
; THEN ITS A SPECIAL CASE. SEE SINIT IN DECLAR.
; THIS CHUNK OF CODE HANDLES THOSE SPECIAL CASES

        CAIN    2,ADRPI         ;PI
        JRST    GRI3
        CAIN    2,SPTADR        ;SPT
        JRST    GRI3A
        CAIN    2,EPSADR        ;EPS
        JRST    GRI3B

; THE ASSUMPTION IS IF YOU GET HERE ITS EITHER CHARTABLE OR ASCTABLE
;   TRICKY SAVE-ONE-LINE CODE TO FOLLOW
        ADDI    0,ASCTBL-ASCADR ;ADJUST FOR ASCTABLE
        CAIL    2,CHRADR        ;WAS IT REALLY ASCTABLE
        ADDI    0,CHRTBL-CHRADR-ASCTBL+ASCADR   ; NO, ADJUST FOR CHARTABLE
; ASCADR,CHRADR POINT INTO THE MODULES LOSEG AREA
; ASCTBL,CHRTBL ARE WHERE THE REAL TABLE CONTROL BLOCKS OR WHATEVER ARE
; SO IF YOU HAD MOVEM 3,ASCADR+2 IN AC0 BEFORE,YOU WANT MOVEM 3,ASCTBL+2
        J       GRI14
;                       GRI 3A
GRI3A:  HRRI    0,SPOINT
        J       GRI14
GRI3B:  HRRI    0,EPS
        J       GRI14
;                       GRI 3
GRI3:HRR 0,PIFXP
        M       3,r%cdlc
        MM      3,PIFXP
;                       GRI 4
        TRNN    0,^O777777
        J       GRI14
        MI      1,2
        J       GRI16
;                       GRI 8  UVAR and not a special case  or WLOC
GRI8:   SKIPN   DSFLG
        J       GRI15
;                       GRI 9
        TLNN    0,^O17
        J       GRI11
;                       GRI 10
        CALL    CXR2,<$,CMSG+10,MONOCR>
        AOS     CERCNT
        J       GRI14
;                       GRI 11
GRI11:  TLO     0,UVARR
        CAIE    1,3
        TLO     0,WLOCR-UVARR
;                       GRI 14
GRI14:  SETZ    1,0
        J       GRI16
;                       GRI 15
GRI15:  SUBI    1,2
;                       GRI 16
GRI16:
        MM      0,INS
        MM      1,SEG
        skiple  cdeflg
        CALL    PCOD
        SKIPE   RELFLG  ; REL FILE REQUESTED?
        JRST    GRI$$   ;  NO
        scall   r%cdsh,<$,ins,$,seg>
;                               EXIT GRI
GRI$$:  RETURN  GRI
        SUBTTL GRJ
        DCL     GRJ

;                               GRJ 1
        JUMPE   1,GRJ3

;                               GRJ 2
        HRR     0,1
        MI      1,LOC

;                               GRJ 3
GRJ3:   CALL    GRI

;                               EXIT GRJ
GRJ$$:  RETURN  GRJ
        SUBTTL GRLB  DETERMINE RELOCATION MODE (SEG) FOR A PROCEDURE CALL
        DCL     GRLB,<PROP>
;                       GRLB 1
        M       1,PROP
        FGET    0,1,PUSD
        JUMPN   0,GRLB7
;                       GRLB 2
        FGET    0,1,PFXP        ;PROP IN R1 FROM BOX 1
        JUMPN   0,GRLB4
;                       GRLB 3
        SETZ    1,0
        J       GRLB$$
;                       GRLB 4
GRLB4:  FGET    0,1,PMODD
        CAIE    0,5
        J       GRLB6
;                       GRLB 5
        MI      1,LVR
        J       GRLB$$
;                       GRLB 6
GRLB6:  MI      1,LOC
        J       GRLB$$
;                       GRLB 7
GRLB7:  MI      1,WLOC
;                       EXITT GRLB
GRLB$$: RETURN  GRLB
        SUBTTL GRM      GENERATE AN INSTRUCTIO TO MOVE OPERAND TO REG. RGX
        DCL     GRM,<RGX,OP>,<OPCO,SCD>

;                               GRM 1
        M       2,OP
        FGET    1,2,OM
        CAIN    1,OTMP
        J       GRM6
        CAIE    1,OUVAR
        J       GRM7

;                               GRM 2
        SETZM   SCD

;                               GRM 3
        M       2,OP
        FGET    1,2,OV
        JN      1,GRM5

;                               GRM 4
        MOVEI   1,O(MOVEI)
        MM      1,OPCO
        MI      1,UVAR
        J       GRM8

;                                       GRM 5
GRM5:   MOVEI   1,O(MOVE)
        MM      1,OPCO
        MI      1,UVAR
        J       GRM8

;                               GRM 6
GRM6:   M       1,OP
        FGET    0,1,OV
        MOVEI   2,0
        FPUT    2,1,OV
        CALL    TQFRE
        MI      1,1
        MM      1,SCD
        MOVEI   1,O(MOVEI)
        MM      1,OPCO
        MI      1,LVR
        J       GRM8

;                               GRM 7
GRM7:   CALL    IMPOS

;                               GRM 8
GRM8:   M       2,OP
        FGET    0,2,OL
        M       2,OPCO
        DPB     2,OPCDZ
        M       2,RGX
        DPB     2,ACZ
        CALL    GRI

;                               EXIT GRM
        RETURN  GRM,<$,SCD>
        SUBTTL GRNT GENERATE THE INSTRUCTION. DO NOT USE AN IMMEDIATE OPERAND
        DCL     GRNT,<I,RGX,OP>

;                               GRNT 1
        SETZ    0,0
        M       3,I
        DPB     3,OPCDZ
        DPB     1,ACZ
        FGET    1,2,OM
        JUMPE   1,GRNT9
        CAIE    1,OSUB
        J       GRNT5
;                       GRNT 2
        FGET    3,2,OL
        CAILE   3,15
        J       GRNT4
;                       GRNT 3
        DPB     3,XRZ
        SETZ    1,0
        J       GRNT8
;                       GRNT 4
GRNT4:  TLO     0,^O20
        HRR     0,3
        MI      1,LVR
        J       GRNT8
;                       GRNT 5
GRNT5:  CAIE    1,OUVAR
        SUBI    1,1
;                       GRNT 7
        FGET    3,2,OL
        HRR     0,3
;                       GRNT 8
GRNT8:  CALL    GRI
        J       GRNT$$
;                       GRNT 9
GRNT9:  MM      0,I
        MOVE    1,OP
        FGET    0,1,OT
        FGET    2,1,OL
        FGET    1,1,OV
        CALL    CLIT
        MOVE    0,I
        HRR     1,2
        CALL    GRJ
;                       EXIT GRNT
GRNT$$: RETURN  GRNT
        SUBTTL GRNT2  GENERATE THE SECOND INSTRUCTION OF A TWO INSTRUCTION GRNT
        DCL     GRNT2,<I,RGX,OP>
;                       GRNT2 1
        FGET    3,2,OM
        CAIN    3,OSUB
        J       GRNT23
        CAIE    3,OKON
        J       GRNT26
;                       GRNT2 2
        MOVE    1,OP
        FGET    1,1,OL
        CALL    CLIT,<REAL>
        SETZ    0,
        M       1,I
        DPB     1,OPCDZ
        M       1,RGX
        DPB     1,ACZ
        HRRZ    1,2             ; AC2 CONTAINS FXADR FROM CLIT ABOVE
        CALL    GRJ
        J       GRT2$$
;                       GRNT2 3
GRNT23: FGET    3,2,OL
        JUMPLE  3,GRNT25
        CAIL    3,16
        J       GRNT25
;                       GRNT2 4
        MOVEI   0,1
        DPB     3,XRZ
        M       1,I
        DPB     1,OPCDZ
        M       1,RGX
        DPB     1,ACZ
        SETZ    1,0
        CALL    GRI
        J       GRT2$$
;                       GRNT2 5
GRNT25: CALL    IMPOS
;                       GRNT2 6
GRNT26: FGET    0,2,OL
        ADDI    0,1
        M       1,RGX
        DPB     1,ACZ
        M       1,I
        DPB     1,OPCDZ
;                       GRNT2 7
GRNT27: CAIN    3,OUVAR
        J       GNT210
        CAIN    3,OLVAR
        J       GNT29
;                       GRNT2 8
        SETZ    1,0
        J       GNT211
;                       GRNT2 9
GNT29:  MI      1,LVR
        J       GNT211
;                       GRNT2 10
GNT210: MI      1,UVAR
;                       GRNT2 11
GNT211: CALL    GRI
;                       EXIT GRNT2
GRT2$$: RETURN  GRNT2
        SUBTTL GRO GENERATE AN INSTRUCTION. USE A FIXED POINT IMMEDIATE OP IF POSSIBLE
        DCL     GRO

;                               GRO 1
        FGET    3,2,OT
        CAILE   3,INT
        J       GRO3

;                               GRO 2
        CALL    GROF
        J       GRO$$

;                               GRO 3
GRO3:   CALL    GRNT

;                               EXIT GRO
GRO$$:  RETURN  GRO
        SUBTTL GROF
        DCL     GROF,<I,RGX,OP>
;                       GROF 1
        CALL    TIM,<$,OP>
        JUMPG   1,GROF4
        JUMPE   1,GROF3
;                       GROF 2
        CALL    GRNT,<$,I,$,RGX,$,OP>
        J       GROF$$
;                       GROF 3
GROF3:  M       1,OP
        FGET    0,1,OV
        M       1,I
        ADDI    1,1
        DPB     1,OPCDZ
        M       1,RGX
        DPB     1,ACZ
        SETZ    1,0
        CALL    GRI
        J       GROF$$
;                       GROF 4
GROF4:  M       1,I
        CAIN    1,O(MOVE)
        MI      1,O(HRLZ)
        ADDI    1,1
;                       GROF 7
        M       2,OP
        FGET    3,2,OV
        HLRZ    0,3
        DPB     1,OPCDZ
        M       1,RGX
        DPB     1,ACZ
        SETZ    1,0
        CALL    GRI
;                       EXIT GROF
GROF$$: RETURN  GROF
        SUBTTL GR1M     GENERATE A MATRIX ADDRESS FOLLOWING AN XRUN CALL
        DCL     GR1M,,<SCD>

;                               GR1M 1
        CALL    SAVREG
        CALL    GRM,<3,$,O2P>,<SCD>
        CALL    OREM,<1>
        MOVSI   0,(MOVEI)
        HRR     0,SCD
        CALL    GRI,<,0>

;                               EXIT GR1M
        RETURN  GR1M
        SUBTTL GR2M      GENERATE TWO MATRIX ADRESSES FOR A RUNSIDE CALL
        DCL     GR2M,,<SCD>

;                               GR2M 1
        CALL    SAVREG
        CALL    GRM,<3,$,O2P>,<SCD>
        CALL    GRM,<2,$,O1P>
        LSH     1,2
        ADDM    1,SCD
        MOVSI   0,(MOVEI)
        M       1,SCD
        HRR     0,1
        CALL    GRI,<,0>
        CALL    OREM,<2>

;                               EXIT GR2M
        RETURN  GR2M
        SUBTTL GTVID  GET AND STACK A VARIABLE
        DCL     GTVID,,<SDTP,ID>

;                               GTVID 1
        CALL    GETID,,<SDTP,ID>

;                               GTVID 2
        CALL    TVID,<$,SDTP,$,ID>

;                               EXIT GTVID
        RETURN  GTVID
        SUBTTL IMPOS  PRINT 'IMPOSSIBLE' AND RESUME
        DCL     IMPOS

;                               IMPOS 1
        CALL    CERR,<10>

;                               EXIT IMPOS
        RETURN  IMPOS
        SUBTTL JMP  GENERATE AN UNCONDITIONAL BRANCH
        DCL     JMP,<ADDR>

;                               JMP 1
        SKIPE   ADDR
        J       JMP3

;                               JMP 2
        CALL    GRSH,<O(JRST),0,0>
        J       JMP$$

;                               JMP 3
JMP3:   CALL    GR,<O(JRST),0,0,0,$,ADDR,LOC>

;                               EXIT JMP
JMP$$:  RETURN  JMP
        SUBTTL LD  LOAD OPERAND INTO MOST AVAILABLE REG
        DCL     LD,<OP>,<R,N>

;                               LD 1
        M       2,OP
        FGET    1,2,OM
        CAIN    1,OREG
        J       LD6

;                               LD 2
        FGET    1,2,OT
        CAILE   1,REAL
        J       LD4

;                               LD 3
        MI      1,1
        MM      1,N
        J       LD5

;                               LD 4
LD4:    MI      1,2
        MM      1,N

;                               LD 5
LD5:    CALL    FNDR,<$,N>,<R>
        J       LD7

;                               LD 6
LD6:    FGET    1,2,OL
        MM      1,R

;                               LD 7
LD7:    CALL    LDR,<$,R,$,OP>

;                               EXIT LD
        RETURN  LD,<$,R>
        SUBTTL LDA  LOAD ARGUEMENT
        DCL     LDA
;                       LDA 1
        M       2,O2P
        FGET    1,2,OC
        JRST    @LDTBL(1)
LDTBL:  EXP     LDA2,LDA3,LDA4,LDA5
;                       LDA 2
LDA2:   CALL    AC1
        J       LDA$$
;                       LDA 3
LDA3:   CALL    AC1S
        J       LDA$$
;                       LDA 4
LDA4:   CALL    GR1M
        J       LDA$$
;                       LDA 5
LDA5:   CALL    IMPOS
;                       EXIT LDA
LDA$$:  RETURN  LDA
        SUBTTL LDR   LOAD OPERAND INTO REG R

; program logic for ldr

;  procedure ldr(r,op)

;  ! loads numeric scalar operand op into register r.  if negation bit
;  ! is set, negates its value.

;  ! saves registers as needed and then generates:

;  ! code               data type

;  ! move r,loc         logical/integer/real

;  ! movn r,loc         logical/integer/real negated

;  ! dmove r,loc        double precision

;  ! dmovn r,loc        double precision negated

;  ! dmove r,loc        complex

;  ! dmove r,loc        complex negated
;  ! movns r
;  ! movns r+1

;  ! The code for complex negated could be a pair of MOVNs, but there are
;  ! problems when loc=r+1 or r-1.

;  ! r          = register number
;  ! op         = operand descriptor

;  local opl    ! op.ol (what is it?)
;  local opng   ! op.ong band 1 (1 if negation needed, else 0)
;  local opm    ! op.om (mode or some such)
;  local opt    ! op.ot (data type)
;  local ins    ! instruction to be generated

;  table ldint[4:9] [move,movn,dmove,dmovn,dmove,dmove]

;  ckc(op,onsc)  ! make sure it's a numeric scalar

;  opl := op.ol;  opng := op.ong band 1;  opm := op.om;  opt := op.ot min real

;  ! the code depends on the fact that logical<real, integer<real,
;  ! real=2, double=3, complex=4.

;  eif opm=osub then
;    if opl<=15 then rgsv[opl] := 0
;  fif opm=oreg then
;    do
;    eif opng=0 and opl=r then return  ! already in the right reg and no negation
;    else [rgsv[opl] := 0;  if opt>real then rgsv[opl+1] := 0]
;    end

;  svr(r)

;  eif opt>real then
;    do  ! double or complex
;    svr(r+1)
;    grnt(ins,r,op)
;    rgsv[r] := rgsv[r+1] := (op-@opdstk) div 4
;    if opt=cmplx and opng#0 then  ! complex, negated
;      [gri([movns r],0);  gri([movns r+1],0)]
;    end

;  else
;    do  ! logical, integer, real
;    grof(ins,r,op)
;    rgsv[r] := (op-@opdstk) div 4
;    end

;  if opm=olvar then tqfre(op.ov)

;  op.om := oreg;  op.ol := r;  op.ov := op.ong := 0

;  return

;  end ldr

; code for ldr

        DCL     LDR,<R,OP>,<OPL,OPNG,OPM,OPT,INS>

;                               LDR 1
        CALL    CKC,<$,OP,ONSC>
        M       2,OP
        FGET    1,2,OL
        MM      1,OPL
        FGET    1,2,ONG
        TRZ     1,^O777776
        MM      1,OPNG
        FGET    1,2,OM
        MM      1,OPM
        FGET    1,2,OT

;                               LDR 2
        CAIGE   1,REAL
        MI      1,REAL
        MM      1,OPT
        LSH     1,1
        ADD     1,OPNG
        M       0,LDINT(1)
        MM      0,INS
;                               LDR 11
        M       1,OPM
        CAIN    1,OREG
        J       LDR14
        CAIE    1,OSUB
        J       LDR19

;                               LDR 12
        M       1,OPL
        CAIG    1,15
        SETZM   RGSV(1)
        J       LDR19

;                               LDR 14
LDR14:  M       1,OPNG
        JN      1,LDR16
        M       1,OPL
        CAMN    1,R
;                               LDR 15
        J       LDR$$

;                               LDR 16
LDR16:  M       1,OPL
        SETZM   RGSV(1)

;                               LDR 17
        M       1,OPL
        M       2,OPT
        CAILE   2,REAL
        SETZM   RGSV+1(1)

;                               LDR 19
LDR19:  CALL    SVR,<$,R>

;                               LDR 21
        M       1,OPT
        CAIG    1,REAL
        J       LDR23

;                               LDR 22
        M       0,R
        ADDI    0,1
        CALL    SVR
        CALL    GRNT,<$,INS,$,R,$,OP>
        M       1,OP
        SUBI    1,OPDSTK
        LSH     1,-2
        M       2,R
        MM      1,RGSV(2)
        MM      1,RGSV+1(2)
;                       LDR 22A
        M       1,OPT
        CAIE    1,CMPLX
        J       LDR24A
        SKIPN   OPNG
        JRST    LDR24A
        MOVSI   0,(MOVNS)
        ADD     0,R
        CALL    GRI,<,0>
        MOVE    0,[MOVNS 1]
        ADD     0,R
        CALL    GRI,<,0>
        JRST    LDR24A

;                               LDR 23
LDR23:  CALL    GROF,<$,INS,$,R,$,OP>
        M       1,OP
        SUBI    1,OPDSTK
        LSH     1,-2
        M       2,R
        MM      1,RGSV(2)

;                       LDR 24A
LDR24A: M       1,OPM
        CAIE    1,OLVAR
        J       LDR24
;                       LDR 24B
        M       1,OP
        FGET    0,1,OV
        CALL    TQFRE
;                               LDR 24
LDR24:  M       2,OP
        MI      1,OREG
        FPUT    1,2,OM
        M       1,R
        FPUT    1,2,OL
        MI      1,0
        FPUT    1,2,OV
        MI      1,0
        FPUT    1,2,ONG

;                               EXIT LDR
LDR$$:  RETURN  LDR
LDINT==.-4
        EXP     O(MOVE),O(MOVN),O(DMOVE),O(DMOVN),O(DMOVE),O(DMOVE)
        SUBTTL LDS  PUT ADDRESS OF STRING IN REG R   RETURN STRING CODE
        DCL     LDS,<R,OP>,<SFLG,LITP,MOD,LOK>

;                               LDS 1
        FGET    2,1,OM
        FGET    3,1,OL
        SETZM   SFLG
;                       LDS 2
        CAIE    2,OSUB
        J       LDS3
        CAMN    3,R
        J       LDS$$

;                               LDS 3
LDS3:   MM      2,MOD
        MM      3,LOK
        CALL    SVR

;                               LDS 3 1/2
        MOVE    1,OP
        SUBI    1,OPDSTK
        LSH     1,-2
        MOVE    2,R
        MOVEM   1,RGSV(2)

;                               LDS 4
        M       2,MOD
        CAIE    2,OKON
        J       LDS6

;                               LDS 5
        CALL    TLOC,<$,LIT,$,LOK>,<LITP>
        M       2,LITP
        FGET    1,2,LADR
        M       3,r%cdlc
        FPUT    3,2,LADR
        MOVSI   0,(MOVEI)
        M       3,R
        DPB     3,ACZ
        CALL    GRJ
        MOVE    R1,LITP
        CALL    RDTY
        J       LDS$$

;                               LDS 6
LDS6:   M       0,LOK
        M       1,R
        DPB     1,ACZ
;                       LDS 7
        M       1,MOD
        CAIE    1,OSUB
        J       LDS12
;                       LDS 8
        IOR     0,[MOVE 0,0]
;                       LDS 9
        M       1,LOK
        CAILE   1,15
        J       LDS11
;                       LDS 10
        CALL    GRI,<,0>
        M       1,LOK
        SETZM   0,RGSV(1)
        J       LDS$$
;                       LDS 11
LDS11:  CALL    GRI,<,LVR>
LDS11B: M       2,OP
        FGET    0,2,OV
        CALL    TQFRE
        J       LDS$$
;                       LDS 12
LDS12:  IOR     0,[MI 0,0]
;                       LDS 13
        CAIE    1,OTMP
        J       LDS15
;                       LDS 14
        CALL    GRI,<,LVR>
        MI      1,1
        MM      1,SFLG
        J       LDS11B
;                       LDS 15
LDS15:  CALL    GRI,<,UVAR>
;                                       LDS 16
LDS$$:  M       2,OP
        MI      1,OSUB
        FPUT    1,2,OM
        M       1,R
        FPUT    1,2,OL
        MI      1,0
        FPUT    1,2,OV
;                                       EXIT LDS
        RETURN  LDS,<$,SFLG>
        SUBTTL MMI  GENERATE A MOVE TO MEMORY

;  watch out. this is terrible tricky code
;  the purpose of this routine, i think, is to generate a move to memory
;   instruction
;  ins is the adress of where you want to move the op to
;   its called ins because the actual instruction is built over the address
;  op is of course an operand stack pointer
;  rel is the relocation info used by gri
;   ww,if non zero, will be generated in the code after the instruction. Ive
;    seen it used in stnsc to put out some stuff when you do a trace

;  if the pending negation flag is set in the op, it will be resolved with 
;  a movnm or a dmovnm if possible

;  mmit is a table of opcodes. you acess the table by multiplying the type
;   (promoting logical an integer to real) by 2 and adding the pending
;   negation flag
        DCL     MMI,<INS,OP,REL,WW>

;                               MMI 1
        FGET    4,1,OL
        DPB     4,ACZ
        SETZM   RGSV(4)
;                       MMI 2
        FGET    5,1,OM
        CAIN    5,OREG
        J       MMI4
        CAIE    5,OSUB
        J       MMI13
;                       MMI 3
        IOR     0,[HRRZM 0,0]
        J       MMI14
;                       MMI 4
MMI4:   FGET    5,1,OT
        CAIGE   5,REAL
        MI      5,REAL
        LSH     5,1
        FGET    6,1,ONG
        ADD     5,6
        IOR     0,MMIT(5)
        SETZ    5,0
        FPUT    5,1,ONG
;                       MMI 5
        MM      0,INS
        FGET    5,1,OT
        CAIG    5,REAL
        J       MMI9
;                       MMI 6
        SETZM   RGSV+1(4)
;                       MMI 7
        TLNN    0,^O200000
        J       MMI9
;                       MMI 8
        ADD     0,[^O40000001]
        M       1,2
        CALL    GRI
;                       MMI 9
MMI9:   M       0,INS
        SKIPN   WW
        J       MMI14
;                       MMI 10
        TLNE    0,^O11000
        ADD     0,[^O1000000000]
        TLZ     0,^O770000
        J       MMI14
;                       MMI 13
MMI13:  CALL    IMPOS
;                       MMI 14
MMI14:  CALL    GRI,<,$,REL>
;                       MMI 15
        SKIPN   WW
        J       MMI$$
;                       MMI 16
        CALL    GRI,<$,WW,0>
;                       EXIT MMI
MMI$$:  RETURN  MMI
MMIT=.-3
        MOVNM   0,0
        MOVEM   0,0
        DMOVNM  0,0
        DMOVEM  0,0
        MOVNM   0,0
        DMOVEM  0,0
        SUBTTL MULNG   CALCULATE CORRECT NEGATION BIT FOR RESULT OF ARITHMETIC OPERATION
        DCL     MULNG,<OP1,OP2>

;                               MULNG 1
        M       2,OP1
        FGET    1,2,ONG
        M       4,OP2
        FGET    3,4,ONG
        XOR     1,3
        FPUT    1,2,ONG

;                               EXIT MULNG
        RETURN  MULNG
        SUBTTL NNG1    resolve the pending negation 
        DCL     NNG1,<OP>

;                               NNG1 1
        M       2,OP
        FGET    1,2,ONG
        JE      1,NNG1$$

;                               NNG1 2
        CALL    LD,<$,OP>

;                               EXIT NNG1
NNG1$$: RETURN  NNG1
        SUBTTL NNG12    resolve pending negation for O2P and O1P
        DCL     NNG12
;       NNG12 1
        CALL    NNG1,<$,O2P>
        CALL    NNG1,<$,O1P>

;                       EXIT NNG12
        RETURN  NNG12
        SUBTTL NXT4P  GET THE NEXT 4 PMCS
        DCL     NXT4P

;                               NXT4P 1
        MOVNI   1,4
        ADDM    1,PMCK
        M       2,[POINT 9,1]
        REPEAT  4,<
        ILDB    0,PMCP
        IDPB    0,2
>

;                               EXIT NXT4P
        RETURN  NXT4P
        SUBTTL ONUL  REMOVE N ITEM FROM THE STACK
;       remove from the stack the n items immediatly precedding op k

        DCL     ONUL,<N,K>,<R>

;                               ONUL 1
        SKIPN   ,N
        JRST    ONUL$$

        M       1,K
        CAMG    1,N
        J       ONUL2
        SUBI    1,1             ;SUBTRACT ONE FROM K INSTEAD OF ADDING ONE TO OPDN
        CAMG    1,OPDN
        J       ONUL3A

;                               ONUL 2
ONUL2:  CALL    CERR,<20>

;                       ONUL 3A
ONUL3A: M       1,N
        MM      1,O1P
        M       2,K
        SUBI    2,1
        M       1,OPDL(2)
        MM      1,O2P
;                       ONUL 3B
ONUL3B: FGET    2,1,OC
        CAIE    2,ONSC
        J       ONUL3D
        FGET    2,1,OM
        CAIE    2,OLVAR
        J       ONUL3D
;                       ONUL3C  FREE A NUMERIC SCALER TEMP
        FGET    0,1,OV
        CALL    TQFRE
;                       ONUL3D
ONUL3D: M       1,O2P
        SUBI    1,4
        MM      1,O2P
        SOSLE   O1P
        J       ONUL3B
;                               ONUL 3
ONUL3:  SETZM   R

;                               ONUL 4
ONUL4:  M       1,R
        M       2,RGSV(1)       ;R2 GETS RGSV[R]
        MI      3,RGSV(1)
        M       1,K
        SUB     1,N
        CAMGE   2,1
        J       ONUL8
;                               ONUL 5
; R2 USED FROM BOX 4
        CAMGE   2,K
        J       ONUL7
;                               ONUL 6
; R2 USED FROM BOX 4
        MOVN    1,N
        ADDM    1,0(3)
        J       ONUL8
;                               ONUL 7
; R2 USED FROM BOX 4
ONUL7:  SETZM   0,0(3)

;                               ONUL 8
ONUL8:  AOS     1,R

;                               ONUL 9
        CAIG    1,^D14
        J       ONUL4

;                               ONUL 10
        M       1,K
        CAMLE   1,OPDN
        J       ONUL12

;                               ONUL 11
        M       1,K
        HRLZ    2,OPDL(1)
        SUB     1,N
        HRR     2,OPDL(1)
        M       3,OPDN
        SUB     3,N
        M       3,OPDL(3)
        BLT     2,3(3)

;                               ONUL 12
ONUL12: MOVN    1,N
        ADDB    1,OPDN
        M       2,OPDL(1)
        MM      2,O2P
        M       2,OPDL-1(1)
        MM      2,O1P

;                               EXIT ONUL
ONUL$$: RETURN  ONUL
        SUBTTL ONULL  REMOVE AN OPERAND FROM THE STACK
        DCL     ONULL,<OP>

;                               ONULL 1
        M       1,OP
        SUBI    1,OPDSTK
        LSH     1,-2
        ADDI    1,1
        CALL    ONUL,<1>

;                               EXIT ONULL
        RETURN  ONULL
        SUBTTL OREM      UNSTACK N ITEMS  (This routine is used a lot)
        DCL     OREM,<N>

;                               OREM 1
        CAMLE   0,OPDN          ;DO WE HAVE THAT MANY TO UNSTAK?
        JRST    OREMER

        JUMPE   0,OREM$$
        MOVE    1,O2P           ;GET THE FIRST ONE TO UNSTACK

UNSTAK: FGET    2,1,OM          ;LOOK AT THE MODE
        FGET    0,1,OV          ; and get the value
        FGET    1,1,OL          ; and get the location field
        CAIE    2,OSUB          ; mode=osub and op/ol>15d means temp
        CAIN    2,OLVAR         ;IF ITS A TEMP ,WE SHOULD FREE THE TEMP CELL
        JRST    FREEIT
        JRST    OREM4

FREEIT: CAILE   1,^d15
        CALL    TQFRE


OREM4:  MOVE    0,OPDN          ;IF RGSV(R)=OPDN THEN 0->RGSV(R)  FOR R=1 TO 14
        MOVEI   1,^D14
OREM4A: CAMN    0,RGSV(1)
        SETZM   ,RGSV(1)
        SOJGE   1,OREM4A

        SOS     OPDN            ;OPDN IS NUMBER OF ACTIVE ENTRIES
        MOVE    2,OPDN
        MOVE    1,OPDL(2)
        MOVEM   1,O2P           ;O2P POINTS TO NEXT ONE TO UNSTACK
        SOSLE   N
        JRST    UNSTAK

        MOVE    1,OPDL-1(2)
        MOVEM   1,O1P


;                               EXIT OREM
OREM$$: RETURN  OREM

OREMER: CALL    CERR,<20>
        SUBTTL OPNM
        DCL     OPNM
;                       OPNM 1
        IDIVI   0,8
        PUSH    15,1
        JUMPE   0,.+2
        PUSHJ   15,OPNM
        POP     15,0
        IORI    0,^O60
        JRST    CXTDO

;    The above seven lines of code have been preserved in their original state
;
;       note the PUSH 15,s instead of PUSH P,s
;       note the JUMPE 0,.+2 instead of a SKIPE 0
;       note the recursive PUSHJ 15,OPNM
;       note the JRST to CXTDO, a routine that should be PUSHJed to
;       note the DCL OPNM but no RETURN OPNM
;       note also that although a chart does exist for OPNM, it bares no
;        resemblance at all to this piece of code. The chart refers to
;        locals N,WW, and CDEP and uses byte pointers
;
;  What this does is print in octal the number passed in register 0. It divides
; the number by 8 getting a digit into reg 1. It pushes the digit and calls
; itself. When it runs out of digits the stack looks like this:
;
;  return adr from original call, digit, return adr, digit, return adr . . digit
;
; The POP pops a digit into reg 0, the IORI changes it into ASCII. The JRST to
; CXTDO prints it and does not alter the stack. The return from CXTDO uses the
; return adrress stacked from an earlier call to OPNM. So we get back to the
; POP where we print another digit. We thus print all the digits. The last
; return from CXTDO uses the return adr from the original OPNM call
;
; I dont mind code being tricky but what coder could justify leaving it commentless
        SUBTTL PCOD   PRINT AN INSTRUCTION WORD IN SYMBOLLIC FORM
        DCL     PCOD,<INS,SEG,WW>

;			PCOD 1   PUT OUT THE LINE NUMBER

;			PUT OUT CARRIAGE RETURN, LINEFEED, AND SPACE
        CALL    CXTDO,<13>
        CALL    CXTDO,<10>
        CALL    CXTDO,<" ">

;			PUT OUT THE CURRENT CODE LOCATION, R%CDLC
        CALL    OPNM,<$,r%cdlc>
;			FOLLOWED BY A TAB
        CALL    CXTDO,<^o11>

        MI      1,INS   ; PUT THE INSTRUCTIONS OPCODE INTO WW
        FGET    0,1,OPCD
        MM      0,WW

;			PCOD 1B   PUT OUT THE INSTRUCTION IN OCTAL
        MOVE    1,[ POINT 3,INS ]
        MOVEI   2,^d12  ; number of octal digits to print
PCOD1B: ILDB    0,1     ; get one octal digit
        ADDI    0,"0"   ; convert it to ascii
        PUSH    P,1     ; SAVE R1 AND R2 ON THE STACK
        PUSH    P,2     ; AND CXTDO WILL PRINT THE CHARACTER IN R0
        CALL    CXTDO
        POP     P,2     ; RESTORE R1 AND R2
        POP     P,1
        CAIN    2,7     ; WE PUT A SPACE BETWEEN THE HALF WORDS
        PUSHJ  P,[ PUSH P,1
                  PUSH P,2
                  CALL CXTDO,<" ">
                  POP P,2
                  POP P,1
                  POPJ  P, ]
        SOJG    2,PCOD1B        ; AND CONTINUE UNTILL ALL TWELVE OCTITS ARE PRINTED

;			FOLLOWED BY TWO SPACES BEFORE THE OPCODE
        CALL    CXTDO,<" ">
        CALL    CXTDO,<" ">


;			PCOD 2A  DO WE WANT TO PRINT THIS INSTRUCTION SYMBOLLICLY?
        M       1,WW
        CAIGE   1,^O110
        J       PCOD8A
        CAILE   1,^O677
        J       PCOD8A

;			PCOD 2  PRINT THE MNEMONIC FOR THIS OPCODE
        MOVE    2,[ POINT 6,MNEM(1) ]
        MOVEI   3,6     ; we will print six sixbit characters
PCOD2:  ILDB    0,2     ;GET A SIXBIT CHARACTER
        ADDI    0,^O40  ; CONVERT IT TO ASCII
        PUSH    P,1     ; save r1,r2, and r3 on the stack
        PUSH    P,2
        PUSH    P,3     ; cxtdo will print the character in r0
        CALL    CXTDO
        POP     P,3     ; restore r1,r2, and r3
        POP     P,2
        POP     P,1
        SOJG    3,PCOD2 ; and continue untill all six characters are printed

;		 and then a space to seperate the opcode from the ac
        CALL    CXTDO,<" ">

;		  print the ac field
        MI      1,INS
        FGET    0,1,AC
        CALL    OPNM

;		  followed by a comma
        CALL    CXTDO,<^o54>

;			PCOD 3  IS THE INDIRECT BIT SET?
        MI      2,INS
        FGET    1,2,IND
        JE      1,PCOD5

;			PCOD 4   YES, PRINT N '@'
        CALL    CXTDO,<"@">

;			PCOD 5  PRINT THE ADDRESS FIELD
PCOD5:  MI      1,INS
        FGET    0,1,AD
        CALL    OPNM

;			  PCOD 6   WAS AN INDEX REGISTER SPECIFIED?
        MI      1,INS
        FGET    0,1,XR
        JE      0,PCOD8

;			PCOD 7  PRINT '(' + INDEX REG + ')'
        CALL    CXTDO,<"(">
        MI      1,INS
        FGET    0,1,XR
        CALL    OPNM
        CALL    CXTDO,<")">
        J       PCOD8

;			PCOD 8A  We will only get here if the instruction was not printed symbollicly
        ; put out a couple of tabs to keep the segment name from
        ; looking like an opcode
PCOD8A: CALL    CXTDO,<^o11>
        CALL    CXTDO,<^o11>

;			PCOD 8   PUT OUT A SEGMENT NAME
PCOD8:  M       1,SEG
        M       0,SGNAM(1)
        CALL    TDO,<,MONOCR>

;                               EXIT PCOD
        RETURN  PCOD
        SUBTTL SAMC  CHECK TO MAKE SURE THE TWO OPERANDS ARE OF THE SAME CLASS
        DCL     SAMC

;                               SAMC 1  O2P/OC = O1P/OC ?
        M       2,O1P
        FGET    1,2,OC
        M       4,O2P
        FGET    3,4,OC
        CAMN    1,3
        J       SAMC$$          ; THEY EQUAL SO WE EXIT

;                               SAMC 2 GIVE ERROR 'Incompatible operands'
        CALL    CERR,<8>

;                               EXIT SAMC
SAMC$$: RETURN  SAMC
        SUBTTL SAMTYP  GIVE THE TWO OPERANDS THE SAME TYPE BY PROMOTING THE LOWER
        DCL     SAMTYP

;                               SAMTYP 1
        M       2,O1P
        FGET    1,2,OT
        M       4,O2P
        FGET    3,4,OT
        CAMLE   1,3
        J       SMTYP5
        CAMN    1,3
        J       SMTP$$

;                               SAMTYP 2
        M       2,O2P
        FGET    1,2,OT
        CAIE    1,STR
        J       SMTYP4

;                               SAMTYP 3
        CALL    CERR,<8>

;                               SAMTYP 4
SMTYP4: M       2,O2P
        FGET    1,2,OT
        CALL    CNVRT,<$,O1P>
        J       SMTP$$

;                               SAMTYP 5
SMTYP5: M       2,O1P
        FGET    1,2,OT
        CAIE    1,STR
        J       SMTYP7

;                               SAMTYP 6
        CALL    CERR,<8>

;                               SAMTYP 7
SMTYP7: M       2,O1P
        FGET    1,2,OT
        CALL    CNVRT,<$,O2P>

;                               EXIT SAMTYP
SMTP$$: RETURN  SAMTYP
        SUBTTL SAVREG  SAVE ALL REGISTERS, PROBABLY FOR AN XRUN CALL
        DCL     SAVREG,,<R>

;                               SAVREG 1
        SETZM   R

;                               SAVREG 2
SAVRG2: CALL    SVR,<$,R>,<R>

;                               SAVREG 3
        CAIL    1,10
        J       SVRG$$

;                               SAVREG 4
        AOS     R
        J       SAVRG2

;                               EXIT SAVREG
SVRG$$: RETURN  SAVREG
        SUBTTL SETKXT  SET PROGRAM CONTEXT
        DCL     SETKXT,<LNUM,WW>

        SETZM   SUBNM
;                               SETKXT 1
        CALL    GLNUM,<$,LNUM>

;                               SETKXT 2
        FGET    0,1,LNUMB
        CAMN    0,LNUM
        J       STKXT4

;                               SETKXT 3
        CALL    RCLN
        JRST    SKXT$$

;                               SETKXT 4
STKXT4: FGET    R0,R1,LSUBN     ;get procedure number
        MOVEM   R0,WW
        CALL    RCLN
        SKIPN   WW              ;In a procedure?
        JRST    SKXT$$

        EXTERN  SUBSTK,SUBPTR
        MOVEI   R0,SUBSTK+<NESTLM*SUBSIZ>
        MOVEM   R0,SUBPTR

STKXT5: SKIPN   R1,WW           ;In a procedure?
        JRST    STKXT6

        MOVNI   R2,SUBSIZ
        ADDB    R2,SUBPTR
        MOVEM   R1,(R2)         ;Store current proc # into SUBSTK
        CALL    TLOC,<$,PRODT>
        FGET    R0,R1,PFPROC    ;Containing procedure for this procedure
        MOVEM   R0,WW
        CALL    RCLN
        JRST    STKXT5

;We now have all nested procedures stacked in SUBSTK. Go through them, swapping
;their locals and parameters into the SDT in the proper order.
;First, move the entries down to the bottom of SUBSTK.

STKXT6: MOVEI   R1,SUBSTK+<NESTLM*SUBSIZ>
        SUB     R1,SUBPTR       ;amount to move
        ADDI    R1,SUBSTK
        MOVEM   R1,WW
        HRRI    R0,SUBSTK
        HRL     R0,SUBPTR
        BLT     R0,-1(R1)
        MOVE    R0,WW
        SUBI    R0,SUBSIZ
        MOVEM   R0,SUBPTR       ;now points to top entry in stack
        MOVEI   R1,SUBSTK
        MOVEM   R1,WW

STKXT7: MOVE    R1,(R1)         ;pick up procedure number
        MOVEM   R1,SUBNM        ;swap its locals in
        CALL    SWPSCT
        MOVE    R1,WW
        CAMN    R1,SUBPTR
        JRST    SKXT$$
        ADDI    R1,SUBSIZ
        MOVEM   R1,WW
        JRST    STKXT7

SKXT$$: RETURN  SETKXT
        SUBTTL STHED    GENERATE RHED CALL

;  procedure sthed(lnum)

;  ! Generates statement header, consisting of
;  !  #####L:                   (where ##### is the line #)
;  !    jsp rxo,(if debgsw then rhed else rphed)
;  !    lnum

;  register loc=1       ! previous location for fixup chain
;  register rn=2        ! routine number (rhed or rphed)
;  register ptr=2       ! byte ptr for iisc

;  if debmod#0 and dsflg=0 then
;    do  ! Only for indirect statement in DDT mode
;    [;ptr] _ iisc(lnum,byte.ptr(mbuf,36,7))
;    next.byte(ptr) _ "L";  next.byte(ptr) _ 0
;    rf.symbol(byte.ptr(mbuf,36,7),rslocl,rf.code.loc,rf.code.reloc)
;    end

;  rn := if debgsw then rhed else rphed

;  t := xtbl[rn];  xtbl[rn] := rf.code.loc

;  grj([jsp rxo,],t)
;  gri(lnum)

;  end sthed



        dcl     sthed,<LNUM>

        ifn     debmod,<
        skipe   dsflg
        jrst    sthd1
        call    iisc,<,$,<[point 7,mbuf]>>
        movei   0,"L"
        idpb    0,2
        movei   0,0
        idpb    0,2
        skipe   relflg  ; rel file requested?
        jrst    sthd1
        scall   r%sym,<$,<[point 7,mbuf]>,rslocl,$,r%cdlc,$,r%cdrl>
sthd1:
        >                       ; ifn debmod

        movei   2,rhed
        skipn   debgsw          ; r2 := if debgsw then rhed else rphed
        movei   2,rphed

        move    1,r%cdlc
        exch    1,xtbl(2)       ; r1 := xtbl[r2];  xtbl[r2] := rf.code.loc

        movsi   0,(jsp rxo,)
        call    grj             ; grj([jsp rxo,],r1)

        call    gri,<$,lnum,0>

        return  sthed
        SUBTTL STO  STORE ONE OPERAND INTO ANOTHER
;       this is what finnaly does the move when you say let a=b
;        flg is used for stuff like 'let a,b=c'

        DCL     STO,<OPS,OPD,FLG>,<INS,SEG,RGX,WW>
;                       STO 1   GET TYPE OF SOURCE AND TYPE OF DEST.
        M       3,OPS
        FGET    0,1,OT
        FGET    2,3,OT
        CAMN    0,2
        J       STO2B
        CAIN    0,STR
        J       STO2
        CAIE    2,STR
        J       STO2B
;                       STO 2 INCOMPATABLE TYPES
STO2:   CALL    CERR,<39>
;                 STO 2B  IF FLG=0 AND CLASS=NUMERIC OR STRING SCALER,STACK A COPY OF THE SOURCE
STO2B:  SKIPE   FLG
        J       STO3
        FGET    2,3,OC
        CAILE   2,OSSC
        J       STO3
;                       STO 2C
        CALL    SAVREG          ; YOUVE GOTTA SAVREG BEFORE STACKING A COPY OR RGSV MAY GET SCREWED UP
        CALL    TV,<$,OPS>
        M       3,O2P
        MM      3,OPS
        M       1,OPD
;                       STO 3 USE CLASS OF SOURCE AND DEST TO DECIDE WHERE TO GO
STO3:   FGET    0,1,OC
        FGET    2,3,OC
        IMULI   2,3
        ADD     2,0
        J       @STOTB(2)
STOTB:  EXP     STNSC,IMPOS,STO5,IMPOS,STOSS,STO6,STO4,STO4,STOMX
;                       STO 4
STO4:   CALL    CERR,<40>
;                       STO 5
STO5:   CALL    SAVREG          ; SAVE REGISTERS BEFORE A RUNSIDE ROUTINE
        MOVE    1,OPD
        FGET    1,1,OT
        CALL    CNVRT,<$,OPS>
        CALL    LDR,<1,$,OPS>
        J       STO7
;                       STO 6
STO6:   CALL    SAVREG          ; SAVE REGISTERS BEFORE A RUNSIDE ROUTINE
        CALL    LDS,<2,$,OPS>
        AND     1,FLG
        MOVSI   0,(MOVEI 5,)
        HRR     0,1
        CALL    GRI,<,0>
;                       STO 7
STO7:   CALL    GRM,<3,$,OPD>
        CALL    CXR,<RSSA>
;                       STO 8
STO8:   SKIPE   FLG
        J       STO$$
        M       3,OPS
        FGET    1,3,OC
        MI      0,1
        CAIG    1,OSSC
        CALL    OREM
;                       EXIT STO
STO$$:  RETURN  STO
        SUBTTL STNSC STO.4       STORE A NUMERIC SCALER
        BDCL    STNSC

;                               STNSC 1
        M       2,OPD
        FGET    1,2,OT
        CALL    CNVRT,<$,OPS>
        CALL    TRTST,<$,OPD>,<WW>
        SETZ    0,0

;                               STNSC 2
        M       2,OPD
        FGET    1,2,OM
        CAIN    1,OUVAR
        J       STNSC6
        CAIE    1,OSUB
        J       STNSC7

;                               STNSC 3
        M       2,OPD
        FGET    1,2,OL
        CAIGE   1,15
        J       STNSC5

;                               STNSC 4
        FGET    3,2,OT
        MM      3,RGX
        MI      3,OLVAR
        FPUT    3,2,OM
        MI      3,INT
        FPUT    3,2,OT
        M       0,2
        CALL    LD
        M       2,OPD
        FPUT    1,2,OL
        M       3,RGX
        FPUT    3,2,OT
        MI      3,OSUB
        FPUT    3,2,OM
        SETZ    0,0

;                               STNSC 5
STNSC5: DPB     1,XRZ           ;OPD/OL IN R1
        SETZM   SEG
        J       STNSC8

;                               STNSC 6
STNSC6: FGET    1,2,OL          ; OPD IN R2
        HRR     0,1
        MI      1,UVAR
        MM      1,SEG
        J       STNSC8

;                               STNSC 7   ERROR 'ILLEGAL USE OF PROCEDURE'
STNSC7: CALL    CERR,<^D27>

;                               STNSC 8
STNSC8: M       2,OPS
        FGET    1,2,OM
        CAIE    1,OKON
        J       STNC15
        FGET    1,2,OV
        JN      1,STNC15

;                               STNSC 9
        IOR     0,[SETZM 0,0]
        MM      0,INS
        FGET    1,2,OT
        CAIG    1,REAL
        J       SNSC11
;                       STNSC 10
        ADDI    0,1
        CALL    GRI,<,$,SEG>
        M       0,INS
;                       STNSC 11
SNSC11: SKIPE   WW
        J       SNSC13
;                       STNSC 12
        CALL    GRI,<,$,SEG>
        J       STNC$$
;                       STNSC 13
SNSC13: MI      1,5
        DPB     1,OPCDZ
        CALL    GRI,<,$,SEG>
        CALL    GRI,<$,WW,0>
        J       STNC$$

;                               STNSC 15
STNC15: FGET    1,2,OM          ; OPS IN R2
        CAIN    1,OREG
        J       STNC17

;                               STNSC 16
        MM      0,INS
        CALL    LD,<$,OPS>
        M       0,INS

;                               STNSC 17
STNC17: M       2,OPS
        FGET    1,2,OL
        DPB     1,ACZ
        MM      0,INS
        CALL    MMI,<,$,OPS,$,SEG,$,WW>
        M       1,OPS
        FGET    2,1,OL
        M       0,1
        SUBI    0,OPDSTK
        LSH     0,-2
        MM      0,RGSV(2)
;                       STNSC 18
        FGET    3,1,OT
        CAILE   3,REAL
        MM      0,RGSV+1(2)
;                               EXIT STNSC
STNC$$: J       STO8
        SUBTTL STOSS STO.5       STORE A STRING SCALER OR A STRING ARRAY ELEMENT
        BDCL    STOSS

;                               STOSS 1
        CALL    SAVREG
        ; we have to stack a copy of the operand so that we can retain the
        ; information of wether OPD is a user var or not so that we know
        ; whether to trace it or not in TRCXR
        CALL    TV,<$,OPD>
        CALL    LDS,<1,$,OPS>

        AND     1,FLG
        LSH     1,2
        MOVEM   1,WW
        CALL    LDS,<2,$,OPD>
        MOVSI   0,(MOVEI 5,)
        HRR     0,WW
        CALL    GRI,<,0>
;                               STOSS 2
        HRLZI   2,^O13740
        CALL    TRCXR,<RACMS,$,O2P>
        CALL    OREM,<1>

        SKIPE   FLG
        JRST    STO$$
        CALL    OREM,<1>
        J       STO$$
        SUBTTL STOMX STO.6   STORE A MATRIX
        BDCL    STOMX

; IF OPS.OM = 16,17 OR 18 THEN WE ARE TO DO ZER,CON OR IDN

;                               STOMX 1
STMX1:  CALL    SAVREG
;  GRM will free the temp cell for temp operands. But we dont want this to
;  happen to our destination. So we call TV to stack a copy of the
; operand.(Remember TV zeroes the temp cell rec # in the copy). We then call
; GRM with the stacked copy. and then we unstack it.

        CALL    TV,<$,OPD>
        CALL    GRM,<3,$,O2P>
        CALL    OREM,<1>
;                       STOMX 2
        M       2,OPS
        FGET    1,2,OM
        CAIG    1,15
        J       STOMX6
;                       STOMX 3
        MOVSI   0,(MOVEI)
        CALL    GRI,<,0>
        M       2,OPS
        FGET    1,2,OM
        J       @ZCITB(1)
ZCITB=.-16
STOMX4
STMX4B
STOMX5
;                       STOMX 4   ZER
STOMX4: SETZ    0,0
        J       STMX4C
;                       STOMX 4B  CON
STMX4B: MI      0,1
;                       STOMX 4C
STMX4C: CALL    TVKI
        M       2,OPD
        FGET    1,2,OT
        CALL    CNVRT,<$,O2P>
        CALL    LDR,<1,$,O2P>
        CALL    OREM,<1>
        CALL    CXR,<RSSA>
        J       STMX$$
;                       STOMX 5   IDN
STOMX5: CALL    CKND,<$,OPD,2>
        CALL    CXR,<RAIDN>
        J       STMX$$
;                       STOMX 6
STOMX6: CALL    GRM,<2,$,OPS>
        AND     1,FLG
        LSH     1,2
        MOVSI   0,(MOVEI)
        HRR     0,1
        CALL    GRI,<,0>
        CALL    CXR,<RACMMX>

;                               EXIT STOMX
STMX$$: J       STO$$
        SUBTTL SVFR  MOVE A NUMBER FROM A REG T A PROTECTED AREA
;               used primarily for FOR loops

        DCL     SVFR,<OP>,<INS>

;                               SVFR 1
        M       2,OP
        FGET    1,2,OM
        CAIN    1,OUVAR
        J       SVFR2
        CAIE    1,OLVAR
        J       SVFR3
        FGET    3,2,OV
        JE      3,SVFR3

;                               SVFR 2
SVFR2:CALL LD,<$,OP>
        J       SVFR4

;                               SVFR 3
SVFR3:  CAIE    1,OREG          ;OM IN R1 FROM 1
        J       SVFR$$

;                               SVFR 4
SVFR4:  CALL    MMI,<$,r%vrlc,$,OP,LVR,0>
        M       2,OP
        M       0,r%vrlc
        FPUT    0,2,OL
        MI      3,OLVAR
        FPUT    3,2,OM
        SETZ    3,0
        FPUT    3,2,OV
;                       SVFR 5
        M       1,INS
        CAIGE   1,O(MOVEM)
        AOS     r%vrlc
        AOS     r%vrlc
;                               EXIT SVFR
SVFR$$: RETURN  SVFR
        SUBTTL SVR  SAVE CONTENTS OF REGISTER R
        DCL     SVR,<R>,<LVAR,RN,N,NN,OP>

;                               SVR 1
        M       2,R
        M       1,RGSV(2)
        MM      1,N

;                               SVR 2
        JE      1,SVR$$
        CAIG    1,ORSVD-5
        J       SVR3

;                               SVR 2A
        M       2,R
        SETZM   RGSV(2)
        J       SVR$$

;                               SVR 3
SVR3:   M       1,R
        JLE     1,SVR4
        M       2,RGSV-1(1)
        CAMN    2,N
        J       SVR15

;                               SVR 4
SVR4:   M       1,N
        M       2,OPDL(1)
        MM      2,OP

;                               SVR 5
        FGET    1,2,OM
        CAIN    1,OSUB
        J       SVR7
        FGET    1,2,OT
        CAIG    1,REAL
        J       SVR7

;                               SVR 6
        MI      0,2
        J       SVR8

;                               SVR 7
SVR7:   MI      0,1

; Things get a bit messy here. We are about to move an operand in a register
; to a temp cell. The mode of the operand is either 1-value in a reg or
; 4-addr of value in a reg(OSUB). The problem is that this dense code generator
; dosnt have enough operand modes and cant make an operand that
; is an addr of a value in a temp cell.
; So it keeps the mode = 4 (addr in reg) and moves the operand into a
; temp anyway. 

;                               SVR 8
SVR8:   CALL    TQNFND,,<LVAR,RN>

;                               SVR 9
        CALL    MMI,<$,LVAR,$,OP,LVR,0>

;                               SVR 12
SVR12:  M       2,OP
        MOVE    1,LVAR          ; LVAR -> OP/OL
        FPUT    1,2,OL
        MOVE    1,RN            ; RN -> OP/OV
        FPUT    1,2,OV

;                       SVR 13
; So here we are with mode=osub (addr in reg) and weve just moved the operand
; into a temp cell. it dosnt want to change yhe mode to 2 (temp) because it
; would forget that it had the address of a valueinstead of a value. So it
; will keep mode = OSUB and in assorted places try to keep things sorted
; out. A bug was found where it didnt suceed. There may be more.
        FGET    1,2,OM
        CAIN    1,OSUB
        J       SVR$$

;                       SVR 14
        MI      1,OLVAR
        FPUT    1,2,OM
        J       SVR$$

;                               SVR 15
SVR15:  SUBI    1,1             ;R IN R1 FROM BOX 3
        CALL    SVR,<$,1>,<R>

;                               EXIT SVR
SVR$$:  RETURN  SVR,<$,R>
        SUBTTL SVTQ   MOVE A TEMP CELL OPERAND TO A PROTECTED AREA
        DCL     SVTQ,<OP,LVAR>,<N,LVV,BLTA,TQDP>

;                               SVTQ 1
        M       2,OP
        FGET    1,2,OV
        HLRZ    0,1             ; GET TEMP CELL DESRCIPTOR BLOCK #
        MOVEM   1,TQDP          ; SAVE DESCRIPTOR POINTER
        CAMN    0,BPOINT        ; DO WE HAVE THAT BLOCK?
        JRST    SVTQ1A          ; YES
                                ;       NO, GET IT
        CALL    TBREL,<$,BPOINT>
        HLRZ    0,TQDP          ; GET THE CORRECT BLOCK
        CALL    TBGET

SVTQ1A: HRRZ    1,TQDP          ;GET LOCATION OF DESCRIPTOR WITHIN THE BLOCK
        MOVE    0,TQDBLK(1)     ;GET DESCRIPTOR
        HRRZM   0,LVV           ; SAVE AWAY R%VRLC LOC
        LDB     0,[POINT 16,0,17]
        MOVEM   0,N             ; SAVE AWAY SIZE


;                               SVTQ 2
        M       1,N
        CAIN    1,2
        J       SVTQ4
        CAIE    1,1
        J       SVTQ7

;                               SVTQ 3
        MOVSI   0,(MOVE 1,)
        HRR     0,LVV
        CALL    GRI,<,LVR>
        MOVSI   0,(MOVEM 1,)
        HRR     0,LVAR
        CALL    GRI,<,LVR>
        J       SVTQ9

;                               SVTQ 4
SVTQ4:  MOVSI   0,(DMOVE 1,)
        HRR     0,LVV
        CALL    GRI,<,LVR>
        MOVSI   0,(DMOVEM 1,)
        HRR     0,LVAR
        CALL    GRI,<,LVR>
;                       SVTQ 5
        M       1,OP
        FGET    2,1,OT
        CAIE    2,STR
        J       SVTQ9
;                       SVTQ 6
        MOVSI   0,(MOVEI 2,)
        HRR     0,LVAR
        CALL    GRI,<,LVR>
        M       0,[HRRM 2,-1(1)]
        CALL    GRI,<,0>
        MOVSI   0,(SETZM 0,)
        HRR     0,LVV
        CALL    GRI,<,LVR>
        JRST    SVTQ9

;                               SVTQ 7
SVTQ7:  M       2,OP
        FGET    1,2,ONG
        MOVE    2,.WSTCS(1)
        MM      2,N
        MOVSI   0,(MOVEI 0,)
        HRR     0,LVV
        CALL    GRI,<,LVR>
        MOVSI   0,(MOVEI 1,)
        HRR     0,LVAR
        CALL    GRI,<,LVR>
        CALL    CXR,<RMAD>


;                               SVTQ 9
SVTQ9:  HRLZI   1,^O400000
        HRRZ    2,TQDP
        ANDCAM  1,TQDBLK(2)     ; RESET BUSY BIT
        M       2,OP
        MI      1,0
        FPUT    1,2,OV
        M       1,LVAR
        FPUT    1,2,OL

;                               EXIT SVTQ
        RETURN  SVTQ,<$,N>
        SUBTTL SWP       SWAP O2P AND O1P
        DCL     SWP

;                                SWP 1
        M       1,O1P
        HRLI    1,-4
SWPA:   M       3,0(1)
        EXCH    3,4(1)
        MM      3,0(1)
        AOBJN   1,SWPA

;                               SWP 2
        MI      1,10
;                       SWP 3
SWP3:   M       2,RGSV(1)
        CAMN    2,OPDN
        SOS     RGSV(1)
;                       SWP 5
        ADDI    2,1
        CAMN    2,OPDN
        MM      2,RGSV(1)
;                       SWP 7
        SOJGE   1,SWP3
;                               EXIT SWP
        RETURN  SWP
        SUBTTL TIM   TEST TO SEE IF AN IMMEDIATE OPERAND CAN BE USED
        DCL     TIM,<OP>

;                               TIM 1
        M       2,OP
        FGET    1,2,OC
        CAIN    1,ONSC
        J       TIM3

;                               TIM 2
        CALL    IMPOS

;                               TIM 3
TIM3:   SETO    1,0

;                               TIM 4
        M       2,OP
        FGET    3,2,OM
        CAIE    3,OKON
        J       TIM$$
        FGET    3,2,OT
        CAILE   3,REAL
        J       TIM$$
        FGET    4,2,OV
        CAIN    3,REAL
        J       TIM8
;                       TIM 6
        TLNN    4,^O777777
        SETZ    1,0
        J       TIM$$
;                       TIM 8
TIM8:   TRNN    4,^O777777
        MI      1,1


;                               EXIT TIM
TIM$$:  RETURN  TIM
        SUBTTL TLOG  CONVERT A DEFERRED RELATION TO A LOGICAL VALUE
        DCL     TLOG,,<RGX,OP1,OP2,REL>

;                               TLOG 1
        M       2,O2P
        FGET    1,2,OT
        JE      1,TLOG3

;                               TLOG 2
        IFE     FTCLOG,<HALT>
        IFN     FTCLOG,<BCALL CINT>
        J       TLOG$$

;                               TLOG 3
TLOG3:  BCALL   CTST

;                               EXIT TLOG
TLOG$$: RETURN  TLOG
        SUBTTL CINT TLOG.2  CONVERT THE INTEGRE RESULT OF A COMPARISON TO A LOGICAL VALUE
        IFN     FTCLOG,<
        BDCL    CINT

;                               CINT 1
        CALL    CKT,<$,O1P,INT>
        CALL    LD,<$,O1P>,<RGX>

;                               CINT 2
        M       2,O2P
        FGET    1,2,OM
        MM      1,REL
        M       2,RGX
        M       0,CIN1-1(1)
        DPB     2,ACZ
        CAIN    1,OLE
        HRR     0,2
        CALL    GRI,<,0>

        M       2,RGX
        M       1,REL
        M       0,CIN2-1(1)
        DPB     2,ACZ
        CALL    GRI,<,0>

        M       1,REL
        CAILE   1,OLE
        J       CINT9
        M       0,CIN3-1(1)
        M       2,RGX
        DPB     2,ACZ
        CAIN    1,OLT
        HRR     0,2
        CALL    GRI,<,0>
;                       CINT 9
CINT9:  CALL    OREM,<1>
        MI      1,LOG
        M       2,O2P
        FPUT    1,2,OT
;                               EXIT CINT
        BRETURN CINT
CIN1:CAILE 0,0
        CAILE   0,0
        MOVN    0,0
        JFCL    0,0
        CAIG    0,0
        CAIGE   0,0
        CAIGE   0,0
CIN2:SETZ 0,0
        SETO    0,0
        CAIG    0,0
        JFCL    0,0
        AOJ     0,0
        MI      0,1
        SETZ    0,0
CIN3:MOVN 0,0
        AOJ     0,0
        AOJ     0,0

        >                       ; IFN FTCLOG
        SUBTTL CTST TLOG.3
        BDCL    CTST

;                               CTST 1
        M       2,O2P
        FGET    1,2,OM
        MM      1,REL
        CALL    OREM,<1>
        M       1,O1P
        MM      1,OP1
        M       1,O2P
        MM      1,OP2

;                               CTST 2
        FGET    0,1,ONG
        JE      0,CTST4

;                               CTST 3
        CALL    LD,<$,OP2>

;                               CTST 4
CTST4:  M       2,OP1
        FGET    1,2,ONG
        JE      1,CTST6

;                               CTST 5
        CALL    LD,<$,OP1>

;                               CTST 6
CTST6:  CALL    FNDR,<1>,<RGX>
        CALL    SVR,<$,1>
        CALL    GRSH,<O(SETZ),$,RGX,0>
        CALL    TVR,<$,RGX,LOG>

;                               CTST 7
        M       2,OP1
        FGET    1,2,OM
        CAIE    1,OREG
        J       CTST9

;                               CTST 8
        M       1,OP1
        FGET    0,1,OL
        CALL    CMP,<,$,OP2,$,REL>
        J       CTST14

;                               CTST 9
CTST9:  M       2,OP2
        FGET    1,2,OM
        CAIE    1,OREG
        J       CTST11

;                               CTST 10
        M       1,OP2
        FGET    0,1,OL
        M       4,REL
        M       2,RLRV(4)
        CALL    CMP,<,$,OP1>
        J       CTST14

;                               CTST 11
CTST11: CALL    TIM,<$,OP1>
        JUMPN   1,CTST13

;                               CTST 12
        CALL    LD,<$,OP2>
        M       1,OP2
        FGET    0,1,OL
        M       4,REL
        M       2,RLRV(4)
        CALL    CMP,<,$,OP1>
        J       CTST14

;                               CTST 13
CTST13: CALL    LD,<$,OP1>
        M       1,OP1
        FGET    0,1,OL
        CALL    CMP,<,$,OP2,$,REL>

;                               CTST 14
CTST14: CALL    GRSH,<O(MOVEI),$,RGX,1>
        CALL    ONUL,<2,$,OPDN>

;                               EXIT CTST
        BRETURN CTST



;  THE NEW TEMP CELL ALLOCATION SCHEME

;  Every temp cell has a temp cell descriptor which holds three pieces of
; information: its location, its size, and whether or not it's busy.
;  The size of a temp cell is either 1 or 2 words, for single length or double
; length numeric scalers and for string descriptors,  or more than two words
; for temporary array descriptors. The size is stored in the right 17 bits of
; the left half of the temp cell descriptor. Also the left most bit of the
; size field is set to indicate a temp cell for a string descriptor which
; may  not be used for a double length numeric scaler.
;   The location of a temp cell is determined by RXLVAR (r%vrlc) at the
; time of allocation. The location is stored in the descriptor's right half.
;   The leftmost bit of the descriptor is the busy flag. It is one for a busy
; temp cell, 0 for a free temp cell.
;
;  In the old days, each descriptor was a record, requiring a TLOC or TNEXT
; to access it. This was found to be inefficient so now each record is a block
; of TQSZE descriptors. TQDBLK is a block of core big enough to hold TQSZE
; descriptors. A record number used to be all that was needed to identify a
; descriptor. Now a descriptor pointer is used which has the block # in
; the left half, and a number between 1 and TQSZE in the right. TQSZE is
; large enough so that it is doubtful that more than one block will ever be
; needed. Thus BPOINT, which holds the current block number is almost always 1.
;
;   To find a temp cell for a numeric scaler you call TQNFND with the size in
; AC 0 . To find a temp cell for a string descriptor you call TQSFND. To find
; a temp cell for an array descriptor you call TQAFND with the size in AC 0.
; Presently TQAFND ignores AC 0 and always allocates 30 words. They will find a 
; free temp cell or if none found allocate a new one. It returns a descriptor
; pointer and the temp cell's location. This temp cell must be freed before
; you have finished compiling the current line. This is done by calling
; TQFRE with the descriptor pointer in AC 0 .

;  A call to TQCLR is made after the compilation of every line. This looks
; at every temp cell descriptor to see if any are still busy which would
; constitute an 'internal stack error' . This used to be quite an expensive
; operation when it required one TNEXT for every temp cell after every line.
;
;  See also SVTQ which saves a temp cell in a protected area.
;
               SUBTTL TQNFND   FIND A TEMP CELL FOR A NUMERIC SCALER
        DCL     TQNFND,<N>,<LVAR,RDN>


        CALL    GETTB1

TRYBLK: SETZ    1,              ; AC 1 POINTS TO DESCRIPTOR WITHIN CURRENT BLOCK
TRYDN:  HLRE    0,TQDBLK(1)     ; GET SIZE AND BUSY FIELDS OF TEMP CELL DESC.
        CAMN    0,N             ; EXACT FIT?
        JRST    USEIT
        JUMPE   0,ALOCIT        ; IF NO MORE TEMP CELLS, ALLOCATE A NEW ONE
        AOS     ,1
        CAIGE   1,TQSZE         ; END OF BLOCK?
        JRST    TRYDN           ; TRY THE NEXT DESCRIPTOR

        CALL    NXTBLK
        JRST    TRYBLK          ; TRY THE NEXT BLOCK

USEIT:  HRRZ    0,TQDBLK(1)     ; TQDBLK(1)rh -> LVAR
        MOVEM   0,LVAR
        JRST    TQNF$$

ALOCIT: MOVE    0,R%VRLC        ; R%VRLC -> LVAR,TQDBLK(1)rh
        MOVEM   0,LVAR
        HRRM    0,TQDBLK(1)
        ADD     0,N             ; R%VRLC + N -> R%VRLC
        MOVEM   0,R%VRLC
        MOVE    0,N             ; N -> TQDBLK(1)lh
        HRLM    0,TQDBLK(1)

TQNF$$: HRLZI   0,^O400000      ; SET BUSY
        IORM    0,TQDBLK(1)
        HRL     1,BPOINT
        MOVEM   1,RDN           ; BPOINT, DESC # -> RDN

        RETURN  TQNFND,<$,LVAR,$,RDN>

               SUBTTL TQSFND   FIND A TEMP CELL FOR A STRING DESCRIPTOR
        DCL     TQSFND,,<LVAR,RDN>


        CALL    GETTB1

TQSFD1: SETZ    1,              ; AC1 POINTS TO DESCRIPTOR WITHIN CURRNT BLOCK
TQSFD2: HLRE    0,TQDBLK(1)     ; GET SIZE AND BUSY FIELDS
        CAIN    0,^O200002      ; EXACT FIT AND A STRING TEMP CELL?
        JRST    TQSFD3
        JUMPE   0,TQSFD4        ; IF NO MORE TEMP CELLS, ALLOCATE ONE
        AOS     ,1
        CAIGE   1,TQSZE         ; END OF BLOCK?
        JRST    TQSFD2          ; TRY THE NEXT DESCRIPTOR

        CALL    NXTBLK
        JRST    TQSFD1          ; TRY THE NEXT BLOCK

TQSFD3: HRRZ    0,TQDBLK(1)     ; TQDBLK(1)rh -> LVAR
        MOVEM   0,LVAR
        JRST    TQSF$$

TQSFD4: MOVE    0,R%VRLC        ; R%VRLC -> LVAR,TQDBLK(1)rh
        MOVEM   0,LVAR
        HRRM    0,TQDBLK(1)
        ADDI    0,2             ; R%VRLC + 2 -> R%VRLC
        MOVEM   0,R%VRLC
        MOVEI   0,^O200002      ; MARK IT AS A TEMP CELL FOR STRINGS ONLY
        HRLM    0,TQDBLK(1)

TQSF$$: HRLZI   0,^O400000      ; SET BUSY
        IORM    0,TQDBLK(1)
        HRL     1,BPOINT
        MOVEM   1,RDN           ; BPOINT, DESC #  -> RDN

        RETURN  TQSFND,<$,LVAR,$,RDN>
               SUBTTL TQAFND   FIND A TEMP CELL FOR AN ARRAY DESCRIPTOR
        DCL     TQAFND,<N>,<LVAR,RDN>

        CALL    GETTB1

TQAFD1: SETZ    1,              ; AC1 POINTS TO DESCRIPTOR WITHIN CURRNT BLOCK
TQAFD2: HLRE    0,TQDBLK(1)     ; GET SIZE AND BUSY FIELDS
        CAIN    0,^O30          ; EXACT FIT?
        JRST    TQAFD3
        JUMPE   0,TQAFD4        ; IF NO MORE TEMP CELLS, ALLOCATE ONE
        AOS     ,1
        CAIGE   1,TQSZE         ; END OF BLOCK?
        JRST    TQAFD2          ; TRY THE NEXT DESCRIPTOR

        CALL    NXTBLK
        JRST    TQAFD1          ; TRY THE NEXT BLOCK

TQAFD3: HRRZ    0,TQDBLK(1)     ;TQDBLK(1)rh -> LVAR
        MOVEM   0,LVAR
        JRST    TQAF$$

TQAFD4: MOVE    0,R%VRLC        ; R%VRLC -> LVAR,TQDBLK(1)rh
        MOVEM   0,LVAR
        HRRM    0,TQDBLK(1)
        ADDI    0,^O30          ; R%VRLC + 30 -> R%VRLC
        MOVEM   0,R%VRLC
        MOVEI   0,^O30          ; MARK IT AS A TEMP FOR ARRAYS ONLY
        HRLM    0,TQDBLK(1)

TQAF$$: HRLZI   0,^O400000      ; SET BUSY
        IORM    0,TQDBLK(1)
        HRL     1,BPOINT
        MOVEM   1,RDN           ; BPOINT,DESC # ->RDN

        RETURN  TQAFND,<$,LVAR,$,RDN>
               SUBTTL TQFRE    FREE A TEMP CELL
        DCL     TQFRE,<DSCN>

; this routine will free the temp cell referd to by  DSCN .
; If it wasnt busy , an error is given.

        HLRZ    0,DSCN          ;LEFT HALF OF DSCN HOLDS TEMP DESC. BLOCK #
        JUMPE   0,TQFR$$
        CAMN    0,BPOINT        ;GET THE BLOCK DSCN POINTS TO
        JRST    TQFRE2

        CALL    TBREL,<$,BPOINT>
        HLRZ    0,DSCN
        CALL    TBGET

TQFRE2: HRRZ    1,DSCN          ;RIGHT HALF OF DSCN HOLDS DESCRIPTOR NUM WITHIN BLOCK
        MOVE    0,TQDBLK(1)
        JUMPL   0,TQFRE4        ; IS IT BUSY?

                                ;       NO, GIVE ERROR
        HRLZI   0,^O400000      ; WE SET IT BUSY SO CERR WONT LOOP
        IORM    0,TQDBLK(1)     ; WHEN IT POPS THE OPERAND STACK
        CALL    CERR,<20>

TQFRE4: HRLZI   0,^O400000      ; RESET BUSY BIT
        ANDCAM  0,TQDBLK(1)

TQFR$$: RETURN  TQFRE
               SUBTTL  TQCLR  CLEAR THE BUSY BIT OF ALL TEMP CELL DESCRIPTORS
                                ;       RETURN THE NUMBER FOUND ON (NONE SHOULD BE FOUND ON)

        DCL     TQCLR,,<WW>

; Look at every temp cell that was ever allocated and see if it was left busy.
; this is done after every line.

        DSCNUM==1

        CALL    GETTB1

        SETZM   ,WW             ; ZERO COUNT OF BUSY TEMP CELLS
TQCLR1: SETZ    DSCNUM,
TQCLR2: MOVE    0,TQDBLK(DSCNUM)        ;GET DESCRIPTOR
        JUMPE   0,TQCLR$        ;ZERO DESCRIPTOR MEANS END
        JUMPG   0,TQCLR3        ; IS IT BUSY?
        HRLZI   0,^O400000      ;  YES, UNBUSY IT
        ANDCAM  0,TQDBLK(DSCNUM)
        AOS     ,WW             ;   AND INCREMENT COUNT

TQCLR3: AOJ     DSCNUM,         ; POINT TO NEXT DESCRIPTOR
        CAIGE   DSCNUM,TQSZE    ; END OF BLOCK?
        JRST    TQCLR2
                                ;       YES , GET NEXT BLOCK
        CALL    TBREL,<$,BPOINT>
        AOS     ,BPOINT
        CALL    TBGET,<$,BPOINT>
        JRST    TQCLR1


TQCLR$: RETURN  TQCLR,<$,WW>
               SUBTTL  TBGET   GET A TEMP CELL DESCRIPTOR BLOCK
        DCL     TBGET,<BP>

        MOVEM   0,BPOINT

        CALL    TLOC,<$,TQDT,$,BP>,<TQDP>

        MOVEI   0,TQDBLK        ; WE BLT THE BLOCK TO TQDBLK SO THAT WE
        HRL     0,TQDP          ; CAN FREE IT AND NOT KEEP THE PAGE LOCKED
        MOVEI   1,TQDBLK
        BLT     0,TQSZE-1(1)

        MOVE    R1,TQDP
        CALL    RCLN

        RETURN  TBGET


        SUBTTL  TBREL   RELEASE A TEMP CELL DESCRIPTOR BLOCK
        DCL     TBREL,<BP>

        CALL    TLOC,<$,TQDT,$,BP>,<TQDP>

        MOVE    0,TQDP
        HRLI    0,TQDBLK
        MOVE    1,TQDP
        BLT     0,TQSZE-1(1)

        MOVE    R1,TQDP
        CALL    RDTY

        RETURN  TBREL



        SUBTTL  NXTBLK  GET THE NEXT TEMP CELL DESCRIPTOR BLOCK
        DCL     NXTBLK

        CALL    TBREL,<$,BPOINT>
        AOS     BPOINT
        CALL    TBGET,<$,BPOINT>

        RETURN  NXTBLK



        SUBTTL  GETTB1   GET TEMP CELL DESCRIPTOR BLOCK NUMBER ONE
        DCL     GETTB1

        MOVE    0,BPOINT
        CAIN    0,1
        JRST    GTB1$$

        SKIPE   ,0
        CALL    TBREL

        CALL    TBGET,<1>

GTB1$$: RETURN  GETTB1


        SUBTTL TRCXR    CALL A RUNSIDE ROUTINE AND DO A TRACE
        DCL     TRCXR,<RN,OP,UUON>


;                       TRCXR 1   check to see if we need to do a trace
        SKIPN   DEBGSW
        J       TRCXR2
        FGET    3,1,OM
        CAIN    3,OUVAR
        J       TRCXR3
        CAIE    0,RACXS
        J       TRCXR2
        SUBI    1,4
        FGET    3,1,OM
        CAIN    3,OUVAR
        J       TRCXR3

;                       TRCXR 2   no trace needed
TRCXR2: CALL    CXR
        J       TRXR$$

;                       TRCXR 3   do a trace
TRCXR3: M       3,0
        M       1,XTBL(3)
        M       4,r%cdlc
        MM      4,XTBL(3)
        M       0,2     ; ac2 contains the UUON from the call
        CALL    GRJ

;                       TRCXR 4
        CALL    CXRR,<$,RN>

;                       TRCXR 5   if RN # RACXS (string exchange) then TRXR11
        M       1,RN
        CAIE    1,RACXS
        J       TRXR11

;                       TRCXR 6  if mode=user var then rn := op/ov else 0
        M       2,OP
        FGET    1,2,OM
        FGET    0,2,OV
        CAIE    1,OUVAR
        SETZ    0,0
        MM      0,RN

;                       TRCXR 9 now we look at the other operand. if its mode
;                               is a user var then put itsov in rn left
        SUBI    2,4
        FGET    1,2,OM
        FGET    0,2,OV
        CAIN    1,OUVAR
        HRLM    0,RN
        J       TRXR12

;                       TRCXR 11  op/ot,,op/ov -> rn
TRXR11: M       1,OP
        FGET    2,1,OT
        FGET    0,1,OV
        HRL     0,2
        MM      0,RN

;                       TRCXR 12
TRXR12: CALL    GRI,<$,RN,0>

;                       EXIT TRCXR
TRXR$$: RETURN  TRCXR
        SUBTTL TRTST    TRACE TEST OF SOME SORT
        DCL     TRTST,<OP>

;                               TRTST 1
        SKIPN   DEBGSW
        J       TRTST2
        M       2,OP
        FGET    1,2,OM
        CAIN    1,OUVAR
        J       TRTST3
;                       TRTST 2
TRTST2: SETZ    1,0
        J       TTST$$
;                       TRTST 3
TRTST3: FGET    3,2,OT
        FGET    1,2,OV
        HRL     1,3

;                               EXIT TRTST
TTST$$: RETURN  TRTST
        SUBTTL TTLOG  IF O2P IS A RELATION, CONVERT IT TO A LOGICAL VALUE
        DCL     TTLOG

;                               TTLOG 1
        M       2,O2P
        FGET    1,2,OC
        CAIE    1,OTST
        J       TTLG$$

;                               TTLOG 2
        CALL    TLOG

;                               EXIT TTLOG
TTLG$$: RETURN  TTLOG
        SUBTTL TV   STACK A COPY OF THE OPERAND OP

;  This routine stacks a copy of the operand on the operand stack
;   Its needed because a lot of people clobber their operands. An example
;   of how its used is when you say A,B = PI  lets say A is real and B
;   is an integer. THe operand is converted to an integer when you move it
;   into B so you have to save a copy for A

;  If the operand is a numeric scaler in a reg, pending negation will be
;   resolved
;  Also, if its in a reg,itsmoved to a safe place so that the copy may
;   use the reg
;  if the operand is a temp, the OV field will be zero in the copy. This
;   is because the OV field holds the TQDT record number for a temp and
;   if it were not zeroed an attempt might be made to release the temp cell
;   twice (note: this used to only be done with numeric scaler temps)

        DCL     TV,<OP>,<WW,PNDNEG>

;                               TV 1
        M       5,OP
        FGET    1,5,OM
        FGET    0,5,OC
        CAIN    1,OTMP          ;IS THIS A TEMP?
        JRST    TV4
        CAIE    1,OSUB          ; OSUB WITH OL>15 MEANS ITS A TEMP
        JRST    TV3A
        FGET    2,5,OL
        CAILE   2,15
        JRST    TV4
TV3A:   CAIE    0,ONSC          ;IS THIS A NUMERIC SCALER
        JRST    TV5
        CAIE    1,OREG
        J       TV5
;                       TV 3
        FGET    0,5,OL
        MM      0,WW
        FGET    0,5,ONG
        MOVEM   0,PNDNEG

        CALL    SVR,<$,WW>
        M       5,OP
        FGET    1,5,OT
        CALL    TVR,<$,WW>
        MOVE    5,O2P
        MOVE    0,PNDNEG
        FPUT    0,5,ONG
        J       TV$$
;                       TV 4
TV4:    SETZ    4,0             ;IF WE ARE COPYING A TMP CELL, ZERO OV. BECAUSE WITH A 
        J       TV7             ;TEMP,OV IS THE TQDT # (IF NON ZERO) AND WE DONT WANT TO FREE IT TWICE
;                       TV 5
TV5:    FGET    4,5,OV
;                       TV 7
TV7:    FGET    1,5,OM
        FGET    2,5,OT
        FGET    3,5,OL
        FGET    5,5,ONG
        CALL    TVF
;                       EXIT TV
TV$$:   RETURN  TV
        SUBTTL TVF   STACK AN OPERAND WITH THE GIVEN FIELD VALUES
        DCL     TVF,<CL,MO,TY,LO,VL,NG>

;                               TVF 1
        CALL    TTLOG
        AOS     2,OPDN
        M       1,O2P
        MM      1,O1P
        M       1,OPDL(2)
        MM      1,O2P

;                               TVF 2
        M       2,O2P
        M       1,CL
        FPUT    1,2,OC
        M       1,MO
        FPUT    1,2,OM
        M       1,TY
        FPUT    1,2,OT
        M       1,LO
        FPUT    1,2,OL
        M       1,VL
        FPUT    1,2,OV
        M       1,NG
        FPUT    1,2,ONG

;                               TVF 3
        M       1,MO
        CAIN    1,OSUB
        J       TVF9
        CAIE    1,OREG
        J       TVF$$

;                               TVF 4
        M       1,CL
        CAIE    1,ONSC
        J       TVF$$

;                               TVF 5
        M       1,OPDN
        M       2,LO
        MM      1,RGSV(2)

;                               TVF 6
        M       1,TY
        CAIG    1,REAL
        J       TVF$$

;                               TVF 7
        M       1,OPDN
        M       2,LO
        MM      1,RGSV+1(2)
        J       TVF$$

;                               TVF 9
TVF9:   M       1,CL
        CAIN    1,OMX
        J       TVF$$

;                               TVF 10
        SKIPE   VL
        J       TVF$$

;                               TVF 11
        M       1,OPDN
        M       2,LO
        CAIG    2,^o17  ;because just because the operand says its in a reg
                        ; dosnt mean its not actually in a temp cell.
                        ; This sad kludge is to take care of the case where we
                        ; are making a copy of an operand created in SVR with
                        ; mode = osub but is actually in a TEMP
        MM      1,RGSV(2)

;                               EXIT TVF
TVF$$:  RETURN  TVF
        SUBTTL TVID CREATE AND STACK AN OPERAND FROM THE VARIABLE SDTP POINTS TO
;               SDTP=0 INDICATES AN ARRAY ELEMENT,ACCESS ARRAY ELEMENT IF NESS.

        DCL     TVID,<SDTP,ID>,<KND,TYP,LOK,WW>

;                               TVID 1
        M       2,SDTP
        JE      2,TVID17

;                               TVID 2
        FGET    1,2,SUSED       ; SDTP IN R2, BOX 1
        JN      1,TVID4

;                       TVID 3A
        SKIPN   DSFLG
        J       TVID3
;                       TVID 3B
        CALL    CERR,<32>
;                               TVID 3
TVID3:  CALL    SETDOL,<$,ID>,<TYP>
        M       2,SDTP
        MI      1,1
        FPUT    1,2,SUSED
        MI      1,SSCAL
        FPUT    1,2,SKND
        M       1,TYP
        FPUT    1,2,STYP
        M       1,r%vrlc
        FPUT    1,2,SLOC
        CALL    ALLOCS,<$,TYP>

;                               TVID 4
TVID4:  M       2,SDTP
        FGET    1,2,SKND
        MM      1,KND
        FGET    1,2,STYP
        MM      1,TYP
        FGET    1,2,SLOC
        MM      1,LOK

;                               TVID 5
        M       1,KND
        CAIN    1,SPRO
        J       TVID11
        CAIE    1,SSCAL
        J       TVID12

;                               TVID 6
        M       1,TYP
        CAIE    1,STR
        J       TVID8

;                               TVID 7
        MI      1,OSSC
        MM      1,WW
        J       TVID9

;                               TVID 8
TVID8:  MI      1,ONSC
        MM      1,WW

;                               TVID 9
TVID9:  CALL    TVF,<$,WW,OUVAR,$,TYP,$,LOK,$,ID,0>

;                               TVID 10
        J       TVID$$

;                               TVID 11
TVID11: CALL    CALLF,<$,SDTP,0,1>
        J       TVID$$

;                               TVID 12
TVID12: CAIE    1,SPARY         ; KND IN R1, BOX 5
        J       TVID14

;                               TVID 13
        MI      1,1
        MM      1,WW
        J       TVID15

;                               TVID 14
TVID14: SETZM   WW

;                               TVID 15
TVID15: M       2,SDTP
        FGET    5,2,SN
        CALL    TVF,<OMX,OUVAR,$,TYP,$,LOK,$,WW>

;                               TVID 16
        J       TVID$$

;                               TVID 17
TVID17: CALL    XAEL,<$,O2P,0>

;                               EXIT TVID
TVID$$: RETURN  TVID
        SUBTTL TVKI  STACK AN INTEGER CONSTANT OF VALUE N
        DCL     TVKI,<N>

;                               TVKI 1
        CALL    TVF,<ONSC,OKON,INT,0,$,N,0>

;                               EXIT TVKI
        RETURN  TVKI
        SUBTTL TVMATE   STACK MATRIX NAME
        DCL     TVMATE,<SDTP,NPAR,ID>,<WW>

;                               TVMATE 1
        M       2,SDTP
        FGET    1,2,SKND
        CAIN    1,SARY
        J       TVMTE2
        CAIE    1,SPARY
        J       TVMTE8

;                               TVMATE 2
TVMTE2: FGET    1,2,SN          ; SDTP IN R2, BOX 1
        CAMN    1,NPAR
        J       TVMTE4

;                               TVMATE 3
        CALL    CERRN,<6,$,ID>

;                               TVMATE 4
TVMTE4: FGET    1,2,SKND        ; SDTP IN R2, BOX 1
        CAIE    1,SARY
        J       TVMTE6

;                               TVMATE 5
        SETZM   WW
        J       TVMTE7

;                               TVMATE 6
TVMTE6: MI      1,1
        MM      1,WW

;                               TVMATE 7
TVMTE7: M       1,SDTP
        FGET    2,1,STYP
        FGET    3,1,SLOC
        FGET    5,1,SN
        CALL    TVF,<OMX,OSUB,,,$,WW>
        J       TMTE$$

;                               TVMATE 8
TVMTE8: M       2,SDTP
        FGET    1,2,SN
        CAIE    1,SPRO
        J       TMTE10

;                               TVMATE 9
        CALL    CERR,<22>

;                               TVMATE 10
TMTE10: CALL    CERRN,<7,$,ID>

;                               EXIT TVMATE
TMTE$$: RETURN  TVMATE
        SUBTTL TVR      STACK A NUMERIC SCALER OF TYPE TYP IN REG R
        DCL     TVR,<R,TYP>

;                               TVR 1
        CALL    TVF,<ONSC,OREG,$,TYP,$,R,0,0>

;                               EXIT TVR
        RETURN  TVR

        SUBTTL XAEL  ACESS ARRAY ELEMENT OR SLICE
        DCL     XAEL,<OP,SDTP>,<PRN,LOK,NDIM,NP,N,RND,RGX,PARFLG>


;                               XAEL 1
        M       2,OP
        FGET    1,2,OC
        CAIE    1,OMX
        J       XAEL2
        FGET    1,2,OM
        CAIN    1,OSUB
        J       XAEL3

;                               XAEL 2
XAEL2:  CALL    IMPOS

;                               XAEL 3
XAEL3:  SETZM   0,PRN
        SETZM   0,N
        SETZM   0,RND
        FGET    1,2,OL          ;OP IN R2 FROM BOX 1
        MM      1,LOK
        FGET    1,2,ONG
        MM      1,NDIM
        MM      1,NP
        FGET    1,2,OV
        MOVEM   1,PARFLG        ;OP/OV TELLS US IF WE HAVE A PARAMETER ARRAY
        SUBI    2,4
        MM      2,OP

;                       XAEL 4
XAEL4:  FGET    1,2,OC          ; OP IN R2 FROM BOX 3 OR BOX 13
        CAIL    1,OSC
        JRST    XAEL6
        CAIE    1,ONSC
        JRST    XAEL10

;                       XAEL 5
        BCALL   XNSC
        JRST    XAEL11

;                       XAEL 6
XAEL6:  MOVEI   3,1
        MOVE    2,PRN
        LSH     3,0(2)
        IORM    3,N
        AOS     RND

;                       XAEL 7
        M       1,OP
        FGET    2,1,OC
        CAIE    2,OSC
        JRST    XAEL9

;                       XAEL 8
        BCALL   XSC
        JRST    XAEL11

;                       XAEL 9
XAEL9:  BCALL   XSST
        JRST    XAEL11

;                       XAEL 10
XAEL10: CALL    CERR,<22>

;                       XAEL 11
XAEL11: CALL    ONULL,<$,OP>
        SOS     NP

;                       XAEL 12
        SKIPG   NP
        JRST    XAEL14

;                       XAEL 13
        AOS     PRN
        MOVE    2,OP
        SUBI    2,4
        MM      2,OP
        JRST    XAEL4

;                       XAEL 14
XAEL14: CALL    SAVREG

;                       XAEL 15
        SKIPN   SDTP
        SKIPE   RND
        JRST    XAEL19

;                       XAEL 17
        BCALL   XAL
        JRST    XAEL$$

;                       XAEL 19
XAEL19: BCALL   XSLC

;                       EXIT XAEL
XAEL$$: RETURN  XAEL
        SUBTTL XNSC      LOAD SUBSCRIPT
        BDCL    XNSC

;                       XNSC 1
        CALL    CNVRT,<$,OP,INT>

;                       XNSC 2
        M       1,NDIM
        CAIG    1,2
        J       XNSC4

;                       XNSC 3
        CALL    LD,<$,OP>,<RGX>
        M       0,[MOVEM 0,PREG]
        M       1,RGX
        DPB     1,ACZ
        ADD     0,PRN
        CALL    GRI,<,0>
        J       XNSC5

;                       XNSC 4
XNSC4:  M       0,PRN
        ADDI    0,1
        CALL    LDR,<,$,OP>
        MI      1,ORSVD
        M       2,PRN
        MM      1,RGSV+1(2)

;                       XNSC 5
XNSC5:  BRETURN XNSC
        SUBTTL XSC    SLICE COLON
        BDCL    XSC

;                       XSC 1
        CALL    ONULL,<$,OP>
        MOVNI   1,4
        ADDM    1,OP
        CALL    CNVRT,<$,OP,INT>

;                       XSC 2
        M       1,NDIM
        CAIG    1,2
        J       XSC5

;                       XSC 3
        CALL    LD,<$,OP>,<RGX>
        M       0,[MOVEM 0,PREG]
        M       1,RGX
        DPB     1,ACZ
        ADD     0,PRN
        CALL    GRI,<,0>
        CALL    ONULL,<$,OP>
        MOVNI   1,4
        ADDM    1,OP

;                       XSC 4
        CALL    CNVRT,<$,OP,INT>
        CALL    LD,<$,OP>,<RGX>
        M       0,[HRLM 0,PREG]
        M       1,RGX
        DPB     1,ACZ
        ADD     0,PRN
        CALL    GRI,<,0>
        J       XSC$$

;                       XSC 5
XSC5:   M       0,PRN
        AOJ     0,0
        CALL    LDR,<,$,OP>
        CALL    ONULL,<$,OP>
        MOVNI   1,4
        ADDM    1,OP
        MOVE    2,PRN
        MOVEI   1,ORSVD
        MM      1,RGSV+1(2)

;                       XSC 6
        CALL    CNVRT,<$,OP,INT>
        M       1,PRN
        ADDI    1,1
        CALL    GRO,<O(HRL),,$,OP>

;                       EXIT XSC
XSC$$:  BRETURN XSC
        SUBTTL XSST    SLICE STAR
        BDCL    XSST

;                       XSST 1
        CALL    FNDR,<1>,<RGX>
        CALL    SVR,<$,RGX>
        M       1,NDIM
        CAIG    1,2
        J       XSST3

;                       XSST 2
        SKIPN   PARFLG
        JRST    XSST2A
        MOVSI   0,(MOVE)        ;YES, DO INDIRECT THING ON LOK
        MOVE    1,RGX
        DPB     1,ACZ
        ADD     0,LOK           ; 'MOVE RGX,LOK'
        CALL    GRI,<,LVR>
        MOVE    1,RGX
        MOVSI   0,(MOVE)
        DPB     1,XRZ
        JRST    XSST2B
XSST2A: MOVSI   0,(MOVE)
        ADD     0,LOK
XSST2B: MOVE    1,RGX
        DPB     1,ACZ
        ADD     0,PRN
        ADDI    0,3             ; 'MOVE RGX,LOK+PRN+3' OR 'MOVE RGX,PRN+3(RGX)'
        MOVEI   1,LVR
        SKIPE   PARFLG
        MOVEI   1,ABS
        CALL    GRI
        M       0,[MOVEM 0,PREG]
        M       1,RGX
        DPB     1,ACZ
        ADD     0,PRN
        CALL    GRI,<,0>
        J       XSST$$

;                       XSST 3
XSST3:  MOVE    0,PRN
        ADDI    0,1
        CALL    SVR
        SKIPN   PARFLG
        JRST    XSST3A
        MOVSI   0,(MOVE)
        MOVE    1,RGX
        DPB     1,ACZ
        ADD     0,LOK           ;'MOVE RGX,LOK'
        CALL    GRI,<,LVR>
        MOVE    1,RGX
        MOVSI   0,(MOVE)
        DPB     1,XRZ
        JRST    XSST3B
XSST3A: MOVSI   0,(MOVE)
        ADD     0,LOK
XSST3B: MOVEI   1,1
        ADD     1,PRN
        DPB     1,ACZ
        ADD     0,PRN
        ADDI    0,3             ; 'MOVE PRN+1,LOK+PRN+3' OR 'MOVE PRN+1,PRN+3(RGX)'
        MOVEI   1,LVR
        SKIPE   PARFLG
        MOVEI   1,ABS
        CALL    GRI
        M       1,PRN
        MOVEI   2,ORSVD
        MM      2,RGSV+1(1)

;                       EXIT XSST
XSST$$: BRETURN XSST
        SUBTTL XAL   ACCESS ARRAY ELEMENT
        BDCL    XAL

;                       XAL 1
        M       1,OP
        FGET    2,1,OV
        JUMPN   2,XAL3

;                       XAL 2
        MOVE    4,NDIM
        MOVE    4,.CADR(4)      ;GET ACCESS CODE OFFSET
        ADD     4,LOK
        CALL    GR,<O(PUSHJ),RXP,0,0,,UVAR>
        J       XAL4

;                       XAL 3
XAL3:   MOVSI   0,(MOVE 3,)
        HRR     0,LOK
        CALL    GRI,<,UVAR>
        MOVE    4,NDIM
        MOVE    4,.CADR(4)
        CALL    GR,<O(PUSHJ),RXP,0,3,,0>

;                       XAL 4
XAL4:   M       1,OP
        FGET    2,1,OT
        CAIE    2,STR
        J       XAL6

;                       XAL 5
        MOVEI   3,OSSC
        MM      3,N
        J       XAL7

;                       XAL 6
XAL6:   MOVEI   3,ONSC
        MM      3,N

;                       XAL 7
XAL7:   MOVE    2,N
        FPUT    2,1,OC
        MOVEI   2,2
        FPUT    2,1,OL
        SETZ    2,0
        FPUT    2,1,OV
        FPUT    2,1,ONG
        SUBI    1,OPDSTK
        LSH     1,-2
        MM      1,RGSV+2

;                       EXIT XAL
        BRETURN XAL
        SUBTTL XSLC   GET ARRAY SLICE
        BDCL    XSLC
;                       XSLC 1
        MOVSI   0,(MOVEI)
        HRR     0,N
        CALL    GRI,<,0>
;                       XSLC 1B
        M       2,OP
        FGET    1,2,OV
        MOVSI   0,(MOVEI 3,)
        SKIPE   1
        MOVSI   0,(MOVE 3,)
        HRR     0,LOK
        CALL    GRI,<,UVAR>
;                       XSLC 2
        M       1,SDTP
        JUMPN   1,XSLC4
;                       XSLC 3
        MOVE    0,RND
        MOVE    1,NDIM
        SUB     1,RND
        CALL    .SLCDR
        CALL    TQAFND,<$,1>
        M       3,OP
        FPUT    1,3,OL
        FPUT    2,3,OV
        MI      2,OTMP
        FPUT    2,3,OM
        M       2,RND
        FPUT    2,3,ONG
        M       0,1
        J       XSLC5
;                       XSLC 4
XSLC4:  FGET    0,1,SLOC
XSLC5:  HRLI    0,(MOVEI 4,)
        CALL    GRI,<,LVR>
;                       XSLC 5
        CALL    CXR,<RGSLC>
;                       EXIT XSLC
        BRETURN XSLC
		SUBTTL  SIXBIT MNEMONICS FOR CDE


; Generate list of SIXBIT text for all the PDP10 instruction mnemonics


        DEFINE  I%I(NAME)
        <
        IRP     NAME,
        <
        SIXBIT "NAME"
        >
        >

MNEM==.-^O110

I%I<DFAD,DFSB,DFMP,DFDV,XXXX,XXXX,XXXX,XXXX,DMOVE,DMOVN,FIX,XXXX>
I%I<DMOVEM,DMOVNM,FIXR,FLTR,UFA,DFN,FSC,IBP,ILDB,LDB,IDPB,DPB>
I%I<FAD,FADL,FADM,FADB,FADR,FADRI,FADRM,FADRB,FSB,FSBL,FSBM,FSBB>
I%I<FSBR,FSBRI,FSBRM,FSBRB,FMP,FMPL,FMPM,FMPB,FMPR,FMPRI,FMPRM,FMPRB>
I%I<FDV,FDVL,FDVM,FDVB,FDVR,FDVRI,FDVRM,FDVRB,MOVE,MOVEI,MOVEM,MOVES>
I%I<MOVS,MOVSI,MOVSM,MOVSS,MOVN,MOVNI,MOVNM,MOVNS,MOVM,MOVMI,MOVMM,MOVMS>
I%I<IMUL,IMULI,IMULM,IMULB,MUL,MULI,MULM,MULB,IDIV,IDIVI,IDIVM,IDIVB>
I%I<DIV,DIVI,DIVM,DIVB,ASH,ROT,LSH,JFFO,ASHC,ROTC,LSHC,XXXX>
I%I<EXCH,BLT,AOBJP,AOBJN,JRST,JFCL,XCT,MAP,PUSHJ,PUSH,POP,POPJ>
I%I<JSR,JSP,JSA,JRA,ADD,ADDI,ADDM,ADDB,SUB,SUBI,SUBM,SUBB>
I%I<CAI,CAIL,CAIE,CAILE,CAIA,CAIGE,CAIN,CAIG,CAM,CAML,CAME,CAMLE>
I%I<CAMA,CAMGE,CAMN,CAMG,JUMP,JUMPL,JUMPE,JUMPLE,JUMPA,JUMPGE,JUMPN,JUMPG>
I%I<SKIP,SKIPL,SKIPE,SKIPLE,SKIPA,SKIPGE,SKIPN,SKIPG,AOJ,AOJL,AOJE,AOJLE>
I%I<AOJA,AOJGE,AOJN,AOJG,AOS,AOSL,AOSE,AOSLE,AOSA,AOSGE,AOSN,AOSG>
I%I<SOJ,SOJL,SOJE,SOJLE,SOJA,SOJGE,SOJN,SOJG,SOS,SOSL,SOSE,SOSLE>
I%I<SOSA,SOSGE,SOSN,SOSG,SETZ,SETZI,SETZM,SETZB,AND,ANDI,ANDM,ANDB>
I%I<ANDCA,ANDCAI,ANDCAM,ANDCAB,SETM,SETMI,SETMM,SETMB,ANDCM,ANDCMI,ANDCMM,ANDCMB>
I%I<SETA,SETAI,SETAM,SETAB,XOR,XORI,XORM,XORB,IOR,IORI,IORM,IORB>
I%I<ANDCB,ANDCBI,ANDCBM,ANDCBB,EQV,EQVI,EQVM,EQVB,SETCA,SETCAI,SETCAM,SETCAB>
I%I<ORCA,ORCAI,ORCAM,ORCAB,SETCM,SETCMI,SETCMM,SETCMB,ORCM,ORCMI,ORCMM,ORCMB>
I%I<ORCB,ORCBI,ORCBM,ORCBB,SETO,SETOI,SETOM,SETOB,HLL,HLLI,HLLM,HLLS>
I%I<HRL,HRLI,HRLM,HRLS,HLLZ,HLLZI,HLLZM,HLLZS,HRLZ,HRLZI,HRLZM,HRLZS>
I%I<HLLO,HLLOI,HLLOM,HLLOS,HRLO,HRLOI,HRLOM,HRLOS,HLLE,HLLEI,HLLEM,HLLES>
I%I<HRLE,HRLEI,HRLEM,HRLES,HRR,HRRI,HRRM,HRRS,HLR,HLRI,HLRM,HLRS>
I%I<HRRZ,HRRZI,HRRZM,HRRZS,HLRZ,HLRZI,HLRZM,HLRZS,HRRO,HRROI,HRROM,HRROS>
I%I<HLRO,HLROI,HLROM,HLROS,HRRE,HRREI,HRREM,HRRES,HLRE,HLREI,HLREM,HLRES>
I%I<TRN,TLN,TRNE,TLNE,TRNA,TLNA,TRNN,TLNN,TDN,TSN,TDNE,TSNE>
I%I<TDNA,TSNA,TDNN,TSNN,TRZ,TLZ,TRZE,TLZE,TRZA,TLZA,TRZN,TLZN>
I%I<TDZ,TSZ,TDZE,TSZE,TDZA,TSZA,TDZN,TSZN,TRC,TLC,TRCE,TLCE>
I%I<TRCA,TLCA,TRCN,TLCN,TDC,TSC,TDCE,TSCE,TDCA,TSCA,TDCN,TSCN>
I%I<TRO,TLO,TROE,TLOE,TROA,TLOA,TRON,TLON,TDO,TSO,TDOE,TSOE>
I%I<TDOA,TSOA,TDON,TSON>
        XALL
END
   ]O