


                IMPLEMENTATION OF A NEW STATEMENT IN TBA




          The RESUME statement of TYMBASIC causes control to return from
     the current context to that existing prior to the last program
     interruption.  Control is transferred so as to restart the
     interrupted TYMBASIC statement.

          We wanted to add an optional argument to RESUME which if
     present would represent the line number to which control would
     return.  If no line number appears following a RESUME, then control
     will return to the interrupted statement.

          Obviously, the 2 cases (line number present or not) had to be
     reflected in TYMBASIC intermediate code, that is the PMC code
     generated by PARSE.  PARSE generates PMC strings for each statement.
     CODGEN generates executable PDP-10 instructions from the PMC's plus
     certain tables.  The PMC strings are described in a note labelled
     "7.6.2 Pass 1 Code Formats" which appears near the end of the chart
     book.

          We had the choice of implementing a new PMC optype for RESUME
     line# or modifying the old RESUME PMC to handle both cases.  It was
     decided to add a new PMC, leaving the old RESUME PMC to be used for
     RESUME's where no line number was coded.

          The new PMC string for RESUME line# was modelled after the
     "GOTO" PMC and would consist of 4 9-bit bytes:


             Byte                Significance             ____                ____________
              1              PMC OPTYPE for RESUME line#
             2-4             Integer line #


     In selecting the opcode or optype for the new PMC, I noted that the
     previously defined optypes were in the ranges 0-124 and 235-255
     (decimal).  The reason for this is apparently historical.  The
     ranges do not have significance.  However, do not add new PMC's to
     the interior range (125-234) because certain PMC related tables have
     compressed out this unused space.  Thus code processing these tables
     "understands" the split.  This should be of no concern except when
     adding new PMC types:  do not use optypes from 125-234;  add after
     255 instead.

          So the new RESUME line# PMC optype was chosen as 256 (decimal).
                                                                   Page 2


          The next consideration was now to modify the parsing of a
     RESUME statement to look for a line number and generate the new PMC
     string if one is present.  If a line number is not present, the old
     RESUME PMC string (optype 25) is generated.  I started looking
     through the PARSE charts and quickly found PRESUM (1.5.4.11.12.45).
     The chart is very simple and consists of 2 subroutine calls:  First
     SYMBOL is called and then WLC9.  SYMBOL is PARSE's primary mechanism
     for classifying tokens from the incoming source stream.  SYMBOL does
     a context-free scan from the current point in the source program and
     sets up two PARSE variables C and V to reflect what is scanned.  C
     contains an integer class value (0-27) for the scanned token.  Some
     classes are:


             C-Contents         Class Signified             __________         _____ _________

                  0             commands such as GET,RUN,PMC,ETC.
                  2             statement executed by the run module
                                such as:  LET, GOTO, REAL, etc.

                  6             unary operations
                  7             binary operations

                 etc.


     The value of V is dependent on the class represent by C:

     C-class           Class Significance  Value of V     _______           _____ ____________  _____ __ _
        11            Integer constants    Value of constant
             
        15            string constants     Byte Pointer to string
        20            numeric functions    0=> DBL, 1=> SGN,
                                           2=> INT etc.


     There is a description of the definitions of the C,V values at the
     end of the charts.  The description is labelled "7.3 Symbol
     Definitions" and it details out each class recognized by SYMBOL.
     This information is essential to working in the PARSE area.


          I found out that WLC9 is one of several subroutines which add
     one or more 9-BIT bytes to the current PMC string:

     Routine Action     _______ ______

             WLC9                    Add right most 9 bits of
                                     REGO to current PMC
                                     string as one PMC byte
             WLC18                   Add rightmost 18 bits of REGO
                                     to current PMC string as 2 PMC bytes
             WLC27                   Add 3 PMC bytes from REGO
             WLC36                   Add 4 PMC bytes from REGO
                                     (i.e. all 36 bits)
                                                                   Page 3


          So PRESUM, the routine which handles the RESUME source
     statement calls SYMBOL and then deposites one byte of PMC whose
     value is 25 the RESUME PMC optype.  This PMC string is complete in
     one PMC byte, the optype.

          The call to SYMBOL was mysterious.  By the time control comes
     to PRESUM, the word "RESUME" had obviously been scanned by SYMBOL,
     so why another call to SYMBOL?  It turns out that the convention in
     PARSE, is that you always call SYMBOL once after you have processed
     all your input.  This is probably to facilitate parsing constructs
     where you may or may not process the next token depending upon its
     class and/or value.  That explained the "Extra" call to SYMBOL in
     PRESUM.

          Thinking of the required modifications to PRESUM, it appeared
     that I wanted PRESUM to do the following things:

               1) Call SYMBOL

               2) If C,V indicated that a valid line # type token
     (positive integer less than 1000000) had been scanned, then generate
     the new PMC and 3 bytes of line #.  Then call SYMBOL once more as
     the "extra" call.

               3) If C,V did not indicate a valid line number, generate
     the old RESUME PMC (25) and exit since SYMBOL would have already
     been called an extra time.

          It turned out that there is an extant PARSE subroutine, CKLNUM,
     which does the following:

               1) Call SYMBOL

               2) Set FNUM to zero if a line number type thing was not
     read, else set FNUM to non-zero.

               3) If a line # type thing was read, leave its value in
     LNMB.

          Perfect:  Just change PRESUM to call CKLNUM.  Then check FNUM
     for zero or not.  If FNUM contains zero generate the old RESUME PMC
     via WLC(25).  If FNUM is non-zero, then do WLC9 (256) and WLC27
     (LNMB) to generate the new 4 byte PMC.

          Only one PARSE consideration remains and that relates to the
     display of the new PMC as invoked by the TBA PMC command.  Display
     of PMC strings is handled by routine PMCX chart 1.5.6.4 .  This is a
     large routine described by about 20 pages of charts.  Two tables in
     the assembly module PARSE8.MAC control much of the display:


                                                                   Page 4


     PMCTBL    has one entry per PMC No.  This entry encodes in one word
               some attributes for display of the corresponding PMC.  The
               codification is described directly above the table in
               PARSE8.

     PMCNMS    has one entry per PMC No.  The entry is the PMC display
               name surrounded by quotes.  All the entries seem to be 5
               or less characters.

          I picked "RESU1" as the display name for the new PMC optype.  I
     added this to the end of PMCNMS where it would be found
     corresponding to PMC # of 256.

          I looked at the PMCTBL entry for "GOTO" (PMC # 47) which was
     "4".  "4" signifies "print 3 byte decimal field".  This sounded good
     for RESUME line #, so I added a PMCTBL entry of "4" at the PMCTBL
     position corresponding to PMC #256.  Note that both PMCTBL and
     PMCNMS have been compressed so as not to waste space for unused PMC
     #'s 125-134.  In each case, however, I added on entry to the end of
     the table since my new PMC # was one higher than the previous extant
     PMC #.  Future PMC additions will be done in the same way.

          With the mods to the PARSE8 PMCTBL and PMCNMS, the PARSE part
     of the changes were complete.

          The CODGEN changes required were to implement processing of the
     new PMC for RESUME line #.  The old RESUME PMC processing would
     remain intact.  The new PMC processing had to generate the following
     code for execution:


             MOVEI    1,address-of-line-to-return-to
             PUSHJ   17,RRSUMP


     RRSUMP was additionally a new run time routine entry point.

          I easily found the chart CSTM in COMPIL.MAC.  CSTM invokes the
     appropriate routine to handle the next PMC optype to be processed.
     It does this by executing an indirect indexed jump off of table
     COPTX at the beginning of COMPIL.MAC.  The PMC optype # is used as
     the index value (adjusted for the hole from 125-234).  I added an
     entry to the end of COPTX.  The entry added consisted of the address
     of the code to handle to new PMC.  I added the code itself at the
     end of CSTM.

          By examination of the code to handle the "GOTO" PMC, I found
     the routine CGOTO did exactly what needed to be done first.  CGOTO
     takes a prototype instruction in register zero and then generates
     the instruction filled with an address corresponding to the line #
     from the current PMC string.  CGOTO takes care of forward references
     to line #'s properly.  So the new PMC handling code began by loading
     a "MOVEI 1,0" into register zero and calling CGOTO to generate:
                                                                   Page 5


     MOVEI 1,address-of-line-to-go-to


          Next I wanted to generate a CALL to run time routine RRSUMP.
     RRSUMP was a new run time routine entry point.  In order to add a
     new run time entry point, tables in CMA.MAC and PMA.MAL must be
     modified.  All the run time entry points are given TBA assembly time
     names which are the same as the entry point names themselves.  Thus
     in CMA.MAC and PMA.MAC I made an entry:

     RRSUMP==131

     I chose 131 since the previous high number for a run time entry
     point was:

     RSMREL==130 .

     I then changed the following definition in both PMA.MAC and CMA.MAC:

     XRMAX==RSMREL

     to

     XRXMAX==RRSUMP

     which defines the high # for run time entry points.  In both PMA.MAC
     and CMA.MAC, the table XTBH is ordered by runtime entry point #
     (i.e.  131 for RRSUMP).  XTBH consists of one word per runtime
     routine entry point.  This word contains the radix-50 code for the
     entry name.  To this table I added a new entry in PMA and CMA.MAC.
     The entry was:

     RADIX50 48,RRSUMP

     The "48" part of each entry is information to the loader.

          Having declared a new run time entry point, I was ready to
     cause a call to that routine to be generated.  I looked at CSTM code
     labelled COPT12.  This code handles the old RESUME PMC.  It
     consisted of a call to CXR with RRSUM as the sole argument.  CXR
     does all necessary to generate a call to the run time routine whose
     number is passed as an argument.  Thus after the call to CGOTO (as
     described above) I placed the following line:


     CALL CXR,<RRSUMP> .


                                                                   Page 6


     CXR would then generate the:


     PUSHJ 17,RRSUMP .


     Note that to CXR, the argument is seen as the integer 131 (decimal).
     CXR provides loader linkage to the RADIX50 name as required.
     Finally after the call to CXR, I coded a JRST to COPT$$ to return to
     the correct spot.  In total then, the routine to handle the new PMC
     is:


             CPT256:  MOVE 0,[MOVEI 1,0]
             CALL CGOTO
             CALL CXR,<RRSUMP>
             JRST COPT$$


          Display of generated code as requested by a CDE command is -
     automatically handled by routines under CGOTO and CXR.  In
     particular GRI is a primary routine which generates a word into the
     relocatable.
    