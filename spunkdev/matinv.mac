   TITLE  MATINV
  EXTERN  INVEPS
  ENTRY  MINVRT,MATPRM,DBLVRT,DBLPRM
        EXTERN  INVDET
;  VERSION 16* ACCESSING GAFFS & MINOR OPZ
;  VERSION 14
;  VERSION  13  DBL FIX @ CHECK AGAINST INVEPS
;  VERSION   12
;  VERSION 9  ; DBLRED &TC INSERTED
;  VERSION  7  CLEANUP   AND DOUBLE PREC.
;  VERSION  6  DOUBLE STUBS FOR TBA CHECKOUT
;VERSION 5  DETERMINANT RETURNED IN R0 AFTER MINVRT
; VERSION 3  MODS TO RUN WITHOUT DEBUGGER  PIDUM & DETERMINANT
;  VERSION  1    DEFINITIONS FOR MATRIX INVERSE ROUTINES
; MINVRT AND DBLVRT ARE THE ENTRY POINTS FOR DOUBLE & SINGLE
; MATRIX INVERSION, RESPECTIVELY. ON EXIT R0= THE DETERMINANT. 
;  IF DETERMINANT IS ZERO THE CALL TO MATRIX PERM WILL DO STRANGE
;  UNTOWARD THINGS (WHICH IS NOT TO SAY THAT IT WON'T IN THE NON-ZERO
; CASES.....)
;  IF INVERSE RATHER THAN DET IS DESIRED CALL MATPRM OR
;  DBLPRM  TO ORDER THE RESULT MATRIX.
;  INVDET CONTAINS THE VALUE OF THE DETERMINANT OF THE LAST MATRIX
; INVERTED...
  ;  IT ASSUMES THAT REGISTERS 1-3 CONTAIN PARAMETERS  AS FOLLOWS:
 ;       R1=  ORDER OF THE MATRIX TO BE INVERTED
 ;       R2=  POINTER TO THE FIRST ELEMENT OF MATRIX 'A'
 ;       R3= POINTER TO THE FIRST ELEMENT OF THE FOUR WORKING
 ;     VECTORS R  AND THAT CONTIGUOUS SPACE HAS BEEN DEDICATED SO THAT
;    VECTORS  R(N),C(N),TAG(N),LOC(N)  ARE ALL BUNDLED TOGETHER
;
;

RT==^o16	; Here lies a lonesome symbol, found lost in MC.MAC,
		; who seems to be referenced only from this file.
		;			WM 29 Oct 76

;
;
;  ACCESS  MACROS FOR SINGLE PRECISION INVERSE
;
  DEFINE   GO(A)
<PUSHJ  17,A>
;
;
  DEFINE  GONE < POPJ  17,0>
;
;
  DEFINE IXCK(A,B)
<   ADDI  A,1
   CAMG  A,INVN
  JRST   B  >
;
;
DEFINE  DMAG (A)<
  JUMPG  A,.+2
  DMOVN  A,A  >
;
;
DEFINE  DCAMG(A,B,C)<
  CAMGE  A,B
  JRST  C
  CAME  A,B
  JRST  .+3
  CAMG  A+1,B+1
  JRST  C
>
;
;
DEFINE  DCAMGE(A,B,C)
<  CAMGE  A,B
  JRST C
   CAME  A,B
  JRST  .+3
  CAMGE  A+1,B+1
  JRST  C
>
;
;
;
;

  DEFINE  STORE (A,B,C,D,E<.R>,F<.C>,G<.A>)<
   MOVE  A,@'B'E
   SUBI  A,1
   IMUL   A,INVN
   ADD    A,@'C'F
   MOVEM  D,@'A'G
>

;
 DEFINE PSET(A,B,C,D,E<.A>)<
  MOVE  A,B
  SUBI  A,1
  IMUL  A,INVN
  ADD   A,C
  MOVEI  A,@'A'E
>
;
  DEFINE FETCH(A,B,C,D,E<.R>,F<.C>,G<.A>)<
   MOVE  A,@'B'E
   SUBI  A,1
   IMUL  A,INVN
   ADD   A,@'C'F
   MOVE   D,@'A'G
>
  DEFINE SET (A,B,C,D,E<.R>,F<.C>,G<.A>)<
   MOVE A,@'B'E
   SUBI  A,1
   IMUL  A,INVN
   ADD  A,@'C'F
   MOVEI  D,@'A'G
>
 DEFINE DPSET(A,B,C,D,E<.A>)<
  MOVE  A,B
  SUBI  A,1
  IMUL  A,INVN
  ADD   A,C
  ADD  A,A
  MOVEI  A,@'A'E
>
;
  DEFINE DFETCH(A,B,C,D,E<.R>,F<.C>,G<.A>)<
   MOVE  A,@'B'E
   SUBI  A,1
   IMUL  A,INVN
   ADD   A,@'C'F
  ADD  A,A
  DMOVE   D,@'A'G
>
  DEFINE DSET (A,B,C,D,E<.R>,F<.C>,G<.A>)<
   MOVE A,@'B'E
   SUBI  A,1
   IMUL  A,INVN
   ADD  A,@'C'F
  ADD   A,A
   MOVEI  D,@'A'G
>
  TWOSEG
;
;
   RELOC   0
;   LOCAL STORAGE FOLLOWS....
;   FIRST POINTERS TO THE TARGET ARRAY AND WORKING VECTORS
;  THE MI.  CELLS  POINT DIRECTLY TO THE FIRST ELEMENTS OF THE
;  RESPECTIVE ARRAYS.. THESE ARE USED TO INITIALISE AND LATER
;  GARBAGE COLLECT  AS OPPOSED TO THE INDIRECT CELLS BELOW
;  WHICH ARE USED FOR INDEXED REFERENCES TO THE ARRAYS...
;
MI.A:  0   ;  POINTER TO THE FIRST ELEMENT OF THE ARRAY A(N,N)
MI.R: 0;    POINTER TO FIRST ELEMENT OF VECTOR  R(N)
MI.C:  0 ;  POINTER TO FIRST ELEMENT OF VECTOR C(N)
; 
MI.TAG: 0 ;  POINTER TO FIRST ELEMENT OF VECTOR TAG(N)  USED BY PERM
MI.LOC: 0 ;  POINTER TO FIRST ELEMENT OF VECTOR LOC(N)  USED BY PERM
;
;
;
INVN: 0 ;  CONTAINS N ..ORDER OF ARRAY A
;
;
;
;
;  THE FOLLLOWING ARE LOCAL VARIABLES FOR THE INVERT AND PERM ROUTINES
PIVI:  0
PIVJ: 0
PPASS: 0
PIVOT: 0
  0 ;;  DOUBLE WORD PIVOT FOR DOUBLE
INVSTS: 0
;
;
;
;
;  NEXT ARE INDIRECT POINTER CELLS ....
;  THE NAMING CONVENTION  IS  <REGISTER>,<ARRAY-1>
;  TO ENABLE INDIRECT REFERENCE TO ARRAYS AND VECTORS WITHOUT
;   HAVING TO PERFORM ADDS AT EACH  INDEXED REF
;
;  TAG LOC  S AND D CELLS ARE USED BY MATRIXPERM
T.LOC:0
RJ.TAG:    ;  SAME AS J.TAG
J.TAG: 0
RK.TAG:  ;  SAME AS K.TAG
K.TAG: 0
;
RI.S: 0
RI.D: 0
;
;
;  NOW COME THE INDIRECT CELLS USED BY THE INVERSE ROUTINE
;   INVOLVING  A  R  AND  C
;
RI.R:  0
RI.C:  0
RJ.C: 0
RJ.R: 0
RK.C: 0
RK.R: 0
RP.C: 0
RP.R: 0
RX1.R: 0
;
RX2.C: 0
;
RS.A: 0
RX1.A: 0
RX2.A: 0
;
;
;
;   THE FOLLOWING ARE REGISTER DEFINITIONS FOR INVERSE AND MATRIXPERM
RX1==2
RX2==RX1+1
RS==RX1+2
RI==RX1+3
RJ==RX1+4
RK==RX1+5
RT==RX1+6
RP==RX1+7
;
;
  RELOC  400000
;
;
;
MINVRT:  SETZM  INVSTS  ;  INDICATE SINGLE PRECISION
  GO  PIIZ
  GO  SSPIV
  GO SGLRED
  GO SETDET
  GONE
;
;
DBLVRT:  SETOM  INVSTS
  GO  PIIZ
  GO SDPIV
  GO DBLRED
  GO SETDET
  GONE
;
;
DBLPRM:  GO  MATPRM
  GONE
;
;
;
;
;
;
;
;  PIIZ  IS A SETUP ROUTINE TO INITIALISE FOR INVERSE
;   IT ASSUMES THAT SPACE IS ALLOCATED FOR THE MATRIX  A(N,N)
;   AND THE WORKING VECTORS  R  C  TAG  LOC
;   AND  MI.A  MI.R  MI.C  MI.TAG  MI.LOC  POINT TO 1ST ELEMENTS
;   INVN CONTAINS  'N' THE ORDER OF MATRIX A
;   AND THAT INVEPS CONTAINS AN APPROPRIATE EPS FACTOR
PIIZ:  ;  INITIALIZATION OF ACCESS VECTORS FOR SINGLE AND DOUBLE
;
  MOVEM  1,INVN
  MOVEM  2,MI.A  ;  set pointer to first element of a array
  MOVEM  3,MI.R  ;  set pointer to r vector
  add  3,1  ;  POINT TO C VECTOR
  MOVEM  3,MI.C
  ADD   3,1  ;  POINT TO TAG VECTOR
  MOVEM  3,MI.TAG
  ADD  3,1  ;  NOW POINT TO LOC VECTOR
  MOVEM  3,MI.LOC
;
;
;
;
INVINZ:  MOVE  1,MI.A  ;  SET A INDICRECT CELLS
  SUBI  1,1 ;  POINT TO 1ST ELEMENT -1
  SKIPE  INVSTS  ; SKIP IF SINGLE
  SUBI  1,1
   HRLI  1,RS
   MOVEM  1,RS.A
   HRLI  1,RX1
  MOVEM 1,RX1.A
  HRLI  1,RX2
  MOVEM  1,RX2.A
;
;  NOW DO TAG AND LOC
  MOVE  1,MI.TAG
  SUBI  1,1
  HRLI  1,RJ
  MOVEM  1,J.TAG
  HRLI  1,RK
  MOVEM  1,K.TAG
 MOVE  1,MI.LOC
  SUBI  1,1
  HRLI  1,RT
  MOVEM  1,T.LOC
;
;
;
;
;  NOW DO THE C INDIRECT CELLS
  MOVE  1,MI.C
 SUBI  1,1
  HRLI  1,RI
  MOVEM  1,RI.C
  HRLI  1,RJ
  MOVEM  1,RJ.C
  HRLI  1,RK
  MOVEM  1,RK.C
  HRLI  1,RP
  MOVEM  1,RP.C
  HRLI   1,RX2
  MOVEM  1,RX2.C
;
;
  MOVE  1,MI.R  ;  NOW THE R INDIRECTS
  SUBI  1,1
  HRLI  1,RI
  MOVEM  1,RI.R
  HRLI  1,RJ
  MOVEM  1,RJ.R
  HRLI  1,RK
  MOVEM  1,RK.R
  HRLI  1,RP
  MOVEM  1,RP.R
  HRLI  1,RX1
  MOVEM  1,RX1.R
;
;
   MOVE  0,[1.0]
   MOVEM  0,INVDET

  ;  SET ROW AND COL VECTORS
  ;  R(I)=C(I)=I
    MOVEI  RI,1
  MOVEM  RI,@RI.R
  MOVEM  RI,@RI.C
  ADDI   RI,1
  CAMG  RI,INVN
  JRST  .-4
  GONE   ;  RETURN    END OF PIIZ**** FOR BOTH SINGLE AND DOUBLE
;
;
;
SSPIV:  ;  FIND FIRST PIVOT FOR SINGLE PRECISION !
;    PIVI,PIVJ=1
    MOVEI 0,1
   MOVEM  0,PIVI
   MOVEM  0,PIVJ
;
;       FOR I=1 TO N DO FOR J=1 TO N DO
;       IF ABS(A(I,J))>ABS(A(PIVI,PIVJ))
;       THEN BEGIN PIVI=I; PIVJ=J  ; END
;
    MOVEI  RI,1
ILOOP1:  MOVEI  RJ,1
JLOOP1:  MOVE  RX1,RI
  SUBI  RX1,1
  IMUL  RX1,INVN
  ADD   RX1,RJ
  MOVM  RX1,@RX1.A
  MOVE  RX2,PIVI
  SUBI  RX2,1
  IMUL  RX2,INVN
  ADD  RX2,PIVJ
  MOVM  RX2,@RX2.A
  CAMG  RX1,RX2
  JRST  ENDJ1
  MOVEM  RI,PIVI
  MOVEM  RJ,PIVJ
ENDJ1:  ADDI  RJ,1
  CAMG  RJ,INVN
  JRST  JLOOP1
  ADDI  RI,1
  CAMG  RI,INVN
  JRST ILOOP1
;
;
;
;
;  CHECK FOR AN ALL ZERO ARRAY BY EXAMING THE LARGEST ELEMENT CHOSEN
;  ABOVE
CHKZRO:  MOVE  RI,PIVI
  MOVE  RJ,PIVJ
  FETCH  RX1,RI,RJ,RX1
  JUMPN  RX1,.+2  ;  JUMPS IF LARGEST ELEMENT IS NON-ZERO
  JRST  SINGLR  ;  TREAT AS SINGULAR ARRAY
  GONE   ;  END  OF         SSPIV *************
;
;
;  DONE WITH PRELIMINARIES NOW DO REDUCTION   !!!!!!!!!!!!
SGLRED:   ;  SINGLE PRECISION REDUCTION LOOP  *****
;
;
;
;  START REDUCTION
;  FOR I=1 TO N  DO....          MAIN I LOOP
INVT4:  MOVEI  RI,1
;               R(I)==R(PIVJ);  C(I)==C(PIVJ)
;
ILOOP:  MOVE  RX1,PIVI
  MOVE  RX2,PIVJ
  MOVE  0,@RX1.R
  EXCH  0,@RI.R
  MOVEM 0,@RX1.R
;
  MOVE  0,@RX2.C
  EXCH  0,@RI.C
  MOVEM  0,@RX2.C
;
  FETCH  RX1,RI,RI,RX1
  MOVM  RX1,RX1
  MOVM  0,INVEPS ;  MAKE SURE ITS AN ABX VAL COMPARE BOTH WAYS
  CAMG  0,RX1
  JRST  INVT5
  JRST  SINGLR  ;  MATRIX IS SINGULAR  !
;
;
;
;               FOR J=1 TO N BY -1  (SKIPPING J=I ITERATION)
INVT5:  MOVE  RJ,INVN  ;  DOWNWARD  J LOOP
JLOOP2:  CAMN  RI,RJ
  JRST   ENDJ2  ; SKIP I=J
;
;  A(R(I),C(J))=A(R(I),C(J)) / A(R(I),C(I));
;
;
  SET  RS,RI,RJ,RS
  SET  RX2,RI,RI,RX2
  MOVE  0,0(RS)
  FDVR   0,0(RX2)  ;  RX2 SETTTING TO R(I,I) MUST BE PRESERVED FOR BELOW
  MOVEM  0,0(RS)
;
ENDJ2:  SOJG  RJ,JLOOP2
;
;   DET  =DET * A(R(I),C(J))
;

;  A(R(I),C(I))=1/A(R(I),C(I))
; SET  RX2,RI,RI,RX2  ELIDE THE LOAD --USING RX2 SETTING ABOVE
  MOVE  0,0(RX2)
  FMPRM  0,INVDET  
  MOVE  0,[1.0]
  FDVRM  0,0(RX2)
;
  SETZM  PIVOT  ; SET PIVOT=0
;
;
;               FOR K=1 TO N (SKIPPING K=1) DO
INVT6:  MOVEI  RK,1
KLOOP:  CAMN  RK,RI
  JRST  ENDK
;
;
;               FOR J=N TO 1 BY -1 (SKIPPING I=J) DO
  MOVE  RJ,INVN  ;  INNRJ  IS THE INNER J LOOP
JLOOP:  CAMN  RJ,RI
  JRST  ENDJ
;               A(R[K],C[J])=A(R(K),C(J))-A(RI),C(J))*A(R(K),C(I))
  SET  RS,RK,RJ,RS
  FETCH  RX1,RI,RJ,RX1
  FETCH  RX2,RK,RI,RX2
  FMPR  RX1,RX2
  MOVN  RX1,RX1
  FADRM  RX1,0(RS)
;
;
;               IF K>I  AND J>I AND ABS(A(R(K),C(J))>=
;                       ABS(PIVOT) THEN PIVI=K  ;PIVJ=J
;                       PIVOT=A(R(K),C(J)) ; END
;
;
CAMG  RK,RI
  JRST INVT7
  CAMG  RJ,RI
  JRST INVT7
  MOVM  RX1,0(RS)
  MOVM  0,PIVOT
  CAMGE  RX1,0
  JRST  INVT7
  MOVEM  RX1,PIVOT
  MOVEM  RK,PIVI
  MOVEM  RJ,PIVJ
ENDJ:   ;   END OF J LOOP
INVT7:  SOJG  RJ,JLOOP
;
;
;
;               A(R(K),C(I))=-A(R(I),C(I)*A(R(K),C(I))
;
  SET RS,RK,RI,RS
  FETCH RX1,RI,RI,RX1
  MOVN  RX1,RX1
  FMPRM   RX1,0(RS)
ENDK:  ADDI  RK,1
  CAMG  RK,INVN
  JRST  KLOOP
ENDI:  ADDI  RI,1
  CAMG  RI,INVN
  JRST  ILOOP
  GONE   ;    END OF THE SINGLE PRECISION REDUCTION ********
;
;

;   THIS IS THE END OF THE 231 INVERSE ALGORITHM...
;    NOW ADJUST THE SIGN OF THE DETERMINANT COLLECTED IN INVDET
;  BY SCANNING THE PERMUTATION VECTORS   R  AND  C
;
;               ! TO SET DETERMINANT SIGN
;               FOR PPASS=-1 TO 0
;                    IF PPASS<0 THEN TAG(K)=R(K) FOR K=1 TO N
;                   ELSE  TAG(K)=C(K) FOR K=1 TO N
;                   IF TAG(J)# J THEN TAG(J)==TAG(TAG(J)),INVEPS=-INVEPS
;                          WHILE TAG(J)#J
;                       FOR J=N TO 1 BY -1
;               NEXT PPASS
;
;
;
;
SETDET:  SETOM  PPASS  ;  MARK PASSES  FIRST R   THEN  C
  HRLZ  0,MI.R  ; 
SDSLUP:  MOVE  1,INVN  ;  ORDER OF ARRAY IN 1
   ADD  1,RK.TAG  ; SET UP BLOCK XFR INTO TAG AAVECTOR
  HRR  0,MI.TAG
  BLT  0,0(1)
  MOVE  RJ,INVN  ;  NOW SCAN THE PERMUTATION VECTOR IN TAG
SDSA:  MOVE  RK,@RJ.TAG
SDSB:  CAMN  RJ,RK  ;  IGNORE THE ENTRY IFF= IDEX JN J
  JRST SDSC
  MOVNS   INVDET  ; INVERT SIGN OF DET FOR THIS SWITCH
  EXCH  RK,@RK.TAG
  MOVEM  RK,@RJ.TAG
  JRST  SDSB  ;  NOW SEE IF THIS ENTRY IS ALLIGNED PROPERLY
SDSC:  SOJG  RJ,SDSA  ;  LOP UNTIL INDEX IS EXHAUSTED
  AOSLE  PPASS  ;  TAKE SECOND PASS ON C VECTOR IF PPASS <1
  JRST SDSDUN  
 HRLZ  0,MI.C
  JRST  SDSLUP
SDSDUN:  ;   END OF PERMUTATION ANALYSIS DET HAS CORRECT SIGN IN
         ;   INVDET
    MOVE  0,INVDET ;  RETURN THE DETERMINANT IN RO
     POPJ   17,0  ;  RETURN ON 17 JUMP STACK CALL
;
;
;
;
SINGLR:  ;   ABORTIVE EXIT FROM INVERSE MATRIX IS JUDGED SINGULAR
;               RE: INVEPS  AND INVDET IS SET TO ZERO
   SOJ  17,.+1
   SETZB  0,INVDET
   GONE
;
;
;
;
;
;
;   THIS IS THE END OF THE INVERSE PROCEDURE  IT SHOULD BE
;   FOLLOWED IN  LINE BY THE MATRIX PERMUTATION ROUTINE
;  DRIVER  MATPRM........AND ASSEMBLED AS ONE  FILE
;
;
;
;  TITLE MATPRM
;
;               MATRIX PERMUTATION IS IMPLEMENTED AS A WIRED
;               SUBROUTINE TO THE MATRIX INVERSE ROUTINE
;               TO ELIMINATE SOME OF THE AAWFULS THAT RESULT
;               FROM THE CALL BY NAME ....
;
;               THE FLAG PPASS=0  INDICATES  PASS 1 (1ST CALL)
;       SIMULATING THE CALL::::
;       MATRIXPERM(A(J,P),A(K,P),J,K,R,C,N,P)
 
;               PPASS#0 SIMULATES THE CALL:::
;       MATRIXPERM(A(P,J),A(P,K),J,K,C,R,N,P)
;
;
;   DRIVER FOR MATRIXPERM FROM MATRIXINVERSE
;
MATPRM:  SETZM  PPASS  ;  SET 1ST PASS
  MOVE  0,RI.R
  MOVEM 0,RI.S
  MOVE  0,RI.C
  MOVEM  0,RI.D
  JRST  PERM1  ;  THE CALL (SO TO SPEAK)
;
MATPR1:  SETOM  PPASS  ;  SET 2ND PASSS
  MOVE  0,RI.S
  EXCH  0,RI.D
  MOVEM  0,RI.S
  JRST  PERM1
;
;
ENDINV:  
INVFIN:  POPJ 17,0;  HERE TEST INVSTS#0  TO CHECK THAT INVERSE WAS
;               ; SUCCESSFUL  RELEASEE THE MATRIX A
                ;  IF NOT
                ;  IN EVERY CASE RELEASE THE
                ; R,C,TAG,LOC  VECTORS
;
;
;
;
;
;       NOW START PERMUTATION
;
;               FOR I=1 TO N  DO TAG(I)=LOC(I)=I
PERM1:  MOVEI  0,RI
  HRLM  0,J.TAG  ;  SET INDEX BITS FOR INIT.
  HRLM  0,T.LOC
  MOVEI  RI,1
  MOVEM  RI,@J.TAG
  MOVEM  RI,@T.LOC
  ADDI  RI,1
  CAMG  RI,INVN
  JRST  .-4
;
  MOVEI  0,RT  ;  NOW RESTORE INDIRECT CELLS
  HRLM  0,T.LOC
  MOVEI  0,RJ
  HRLM  0,J.TAG
;
;
;
;               FOR I=1 TO N DO  ...
PERM2:  MOVEI  RI,1
;
;               T=S(I);J=LOC(T);K=D(I)
;
PILOOP:  MOVE  RT,@RI.S
  MOVE  RJ,@T.LOC
  MOVE  RK,@RI.D
;
;               IF  J#K THEN BEGIN...
CAMN  RJ,RK
  JRST  ENDPI
;
;               ...FOR P=1 TO N DO
;               A==B   (THIS IS CALL BY NAME WHICH REQUIRES
;               REEVALUATION OF THE CALL FOR EACH REF.
;
  MOVEI  RP,1
  SKIPE  PPASS  ;  SKIP  ON PASS1
  JRST  PPL2
;
PPL1:  SKIPE  INVSTS  ;  SKIP IF NOT DOBLE
  JRST  DPPL1
PPL1A:  PSET  RX1,RJ,RP,RX1
  PSET  RX2,RK,RP,RX2
  MOVE  0,0(RX2)
  EXCH  0,0(RX1)
  MOVEM  0,0(RX2)
  ADDI  RP,1
  CAMG  RP,INVN
  JRST  PPL1A ; CONTINUE THE LOOP
  JRST  PERM3
;
;
PPL2:  SKIPE  INVSTS
  JRST  DPPL2
PPL2A:  PSET RX1,RP,RJ,RX1
  PSET  RX2,RP,RK,RX2
  MOVE  0,0(RX2)
  EXCH  0,0(RX1)
  MOVEM 0,0(RX2)
  ADDI  RP,1
  CAMG  RP,INVN
  JRST  PPL2A
;
;
PERM3:
;               TAG(J)=TAG(K);  TAG(K)=T
;               LOC(T)=LOC(TAG(J));  LOC(TAG(J))=J
;
  MOVE  0,@K.TAG
  MOVEM  0,@J.TAG
  MOVEM  RT,@K.TAG
;
MOVE  RX1,@J.TAG
ADD  RX1,T.LOC
MOVE  0,0(RX1)
MOVEM  0,@T.LOC
MOVEM RJ,0(RX1)
;
;   END JK CONDITIONAL  
;     END  ILOOP
;
ENDPI:  ADDI  RI,1
  CAMG  RI,INVN
  JRST  PILOOP
;
;   END  MATRIXPERM
   SKIPE  PPASS
   JRST  INVFIN
   JRST  MATPR1
;
DPPL1:  DPSET  RX1,RJ,RP,RX1
  DPSET  RX2,RK,RP,RX2
  DMOVE  0,0(RX2)
  EXCH  0,0(RX1)
  EXCH  1,1(RX1)
  DMOVEM  0,0(RX2)
  IXCK  RP,DPPL1
;
  JRST  PERM3
;
;
;
DPPL2:  DPSET  RX1,RP,RJ,RX1
  DPSET  RX2,RP,RK,RX2
  DMOVE  0,0(RX2)
  EXCH  0,0(RX1)
  EXCH  1,1(RX1)
  DMOVEM  0,0(RX2)
  IXCK  RP,DPPL2
  JRST  PERM3
;
;
;
;
;
;
;
;
;
;
;     DOUBLE PRECISION SUBROUTINES FOLLOW
;
;
SDPIV:  ;  DOUBLE PREC  FIND FIRST PIVOT
;  PIVI,PIVJ=1
  MOVEI  0,1
  MOVEM  0,PIVI
  MOVEM  0,PIVJ
;
;
;               FOR I= 1 TO N DO FOR J=1 TO N DO
;                 IF ABS(A(I,J))>ABS(A(PIVI,PIVJ)) THEN
;                   BEGIN  PIVI=I,PIVJ=J
;
  MOVEI  RI,1
SDPILP:  MOVEI  RJ,1
SDPJLP:  DPSET  RX1,RI,RJ,RX1
   DMOVE 0,0(RX1)
   DPSET  RX1,PIVI,PIVJ,RX1
  DMOVE  RX1,0(RX1)
  DMAG 0
  DMAG  RX1
  DCAMG  0,RX1,SDPIJ
  MOVEM  RI,PIVI
  MOVEM  RJ,PIVJ
SDPIJ:  IXCK  RJ,SDPJLP
  IXCK  RI,SDPILP
;
  MOVE  RI,PIVI
  MOVE  RJ,PIVJ
  DFETCH  RX1,RI,RJ,RX1
  JUMPN  RX1,.+2
  JRST  SINGLR
  GONE
;
;
;
;
;
;
;
DBLRED: ;   DOUBLE PRECISIION  REDUCTION LOOP
;   FOR I=1 TO N DO......
;
   MOVEI  RI,1
;
;               R(I)==PIVI,  C(I)==PIVJ
DILUP:  MOVE  RX1,PIVI
  MOVE  RX2,PIVJ
  MOVE  0,@RX1.R
  EXCH  0,@RI.R
  MOVEM  0,@RX1.R
;
  MOVE  0,@RX2.C
  EXCH  0,@RI.C

  MOVEM  0,@RX2.C
;
;
;  IF ABS(INVEPS)>ABS(A(I,I)) THEN GO TO SINGULAR
  DFETCH  RX1,RI,RI,RX1
  DMOVE  0,INVEPS
  DMAG  0
  DMAG  RX1
  DCAMGE RX1,0,SINGLR
;
;
;               FOR J=N TO 1 BY -1
DBLR5:  MOVE  RJ,INVN
DBLR5A: CAMN  RI,RJ
  JRST  DBLR5B ;  SKIP  ITERATION I=J
;
;
;               A(R(I),C(J)=A(R(I),C(J))/A(R(I),C(I)
  DSET  RS,RI,RJ,RS
  DSET  RX1,RI,RI,RX1 ; RX1 SETTING TO R(I,I) USED IN NEXT EXP ALSO
  DMOVE  0,0(RS)
  DFDV  0,0(RX1)
  DMOVEM  0,0(RS)
;
DBLR5B:  SOJG  RJ,DBLR5A
;
;
;
;
;              DET=DET*A(R(I),C(I))
;
; DSET  RX1,RI,RI,RX1   ; ELIDE THIS SETTING USE RX1 PTR FROM ABOVE EXP
  MOVE  0,0(RX1)  ;  HANDLE DET IN SINGLE PRECISION
  FMPRM  0,INVDET
;
;               A(R(I),C(I)=1/A(R(I),C(I))
  HRLZI  0,201400
  SETZ  1,
  DFDV  0,0(RX1)
  DMOVEM  0,0(RX1)
;
;
  SETZM  PIVOT
  SETZM  PIVOT+1
;
;
;               FOR K=1 TO N  (SKIPPING K=I)
DBLR6:  MOVEI  RK,1
DKLUP:  CAMN  RK,RI
  JRST  ENDDK
;
;
;               FOR J=N TO 1 BY -1 (SKIPPING  I=J)
  MOVE  RJ,INVN
DJLUP:  CAMN  RJ,RI
  JRST  ENDDJ
;
;    A(R(K),C(J))=A(R(K),C(J))-A(R(I),C(J))*A(R(K),C(I))
  DSET  RS,RK,RJ,RS
  DFETCH  RX1,RI,RJ,0
  DSET  RX1,RK,RI,RX1
  DFMP  0,0(RX1)
  DMOVN  0,0
  DFAD  0,0(RS)
  DMOVEM  0,0(RS)
;
;
;   IF K>I  AND J>I  AND  ABS(A(R(K),C(J))>= ABS(PIVOT)  THEN
;               PIVI=K,  PIVJ=J   ,  PIVOT=A(R(K),C(J));  AND
;
;
   CAMG   RK,RI
   JRST  ENDDJ
  CAMG  RJ,RI
  JRST  ENDDJ
  DMOVE  RX1,0(RS)
  DMOVE  0,PIVOT
  DMAG  0
  DMAG  RX1
  DCAMGE  RX1,0,ENDDJ
  DMOVEM  RX1,PIVOT
  MOVEM  RK,PIVI
  MOVEM  RJ,PIVJ
ENDDJ:  SOJG  RJ,DJLUP
;
;
;
;               A(R(K),C(I))=-A(R(I),C(I)*A(R(K),C(I))
  DSET  RS,RK,RI,RS
  DSET  RX1,RI,RI,RX1
  DMOVN  0,0(RX1)
  DFMP  0,0(RS)
  DMOVEM  0,0(RS)
;
;
ENDDK:  IXCK  RK,DKLUP
ENDDI:  IXCK  RI,DILUP
;
  GONE
;
;
   END
   